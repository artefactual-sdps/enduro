/* tslint:disable */
/* eslint-disable */
/**
 * Enduro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ConfirmSipRequestBody,
  EnduroIngestSip,
  MonitorEvent,
  SIPNotFound,
  SIPWorkflows,
  SIPs,
  UploadSipResponseBody,
} from '../models/index';
import {
    ConfirmSipRequestBodyFromJSON,
    ConfirmSipRequestBodyToJSON,
    EnduroIngestSipFromJSON,
    EnduroIngestSipToJSON,
    MonitorEventFromJSON,
    MonitorEventToJSON,
    SIPNotFoundFromJSON,
    SIPNotFoundToJSON,
    SIPWorkflowsFromJSON,
    SIPWorkflowsToJSON,
    SIPsFromJSON,
    SIPsToJSON,
    UploadSipResponseBodyFromJSON,
    UploadSipResponseBodyToJSON,
} from '../models/index';

export interface IngestConfirmSipRequest {
    uuid: string;
    confirmSipRequestBody: ConfirmSipRequestBody;
}

export interface IngestDownloadSipRequest {
    uuid: string;
    enduroSipDownloadTicket?: string;
}

export interface IngestDownloadSipRequestRequest {
    uuid: string;
}

export interface IngestListSipWorkflowsRequest {
    uuid: string;
}

export interface IngestListSipsRequest {
    name?: string;
    aipId?: string;
    earliestCreatedTime?: Date;
    latestCreatedTime?: Date;
    status?: IngestListSipsStatusEnum;
    uploaderId?: string;
    limit?: number;
    offset?: number;
}

export interface IngestMonitorRequest {
    enduroWsTicket?: string;
}

export interface IngestRejectSipRequest {
    uuid: string;
}

export interface IngestShowSipRequest {
    uuid: string;
}

export interface IngestUploadSipRequest {
    contentType?: string;
}

/**
 * IngestApi - interface
 * 
 * @export
 * @interface IngestApiInterface
 */
export interface IngestApiInterface {
    /**
     * Signal the SIP has been reviewed and accepted
     * @summary confirm_sip ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {ConfirmSipRequestBody} confirmSipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * @summary download_sip ingest
     * @param {string} uuid Identifier of the SIP to download
     * @param {string} [enduroSipDownloadTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestDownloadSipRaw(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>>;

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    ingestDownloadSip(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob>;

    /**
     * Request access to SIP download
     * @summary download_sip_request ingest
     * @param {string} uuid Identifier of the SIP to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestDownloadSipRequestRaw(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    ingestDownloadSipRequest(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * List all workflows for a SIP
     * @summary list_sip_workflows ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipWorkflowsRaw(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPWorkflows>>;

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    ingestListSipWorkflows(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPWorkflows>;

    /**
     * List all ingested SIPs
     * @summary list_sips ingest
     * @param {string} [name] 
     * @param {string} [aipId] Identifier of AIP
     * @param {Date} [earliestCreatedTime] 
     * @param {Date} [latestCreatedTime] 
     * @param {'error' | 'failed' | 'queued' | 'processing' | 'pending' | 'ingested'} [status] 
     * @param {string} [uploaderId] UUID of the SIP uploader
     * @param {number} [limit] Limit number of results to return
     * @param {number} [offset] Offset from the beginning of the found set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>>;

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    ingestListSips(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs>;

    /**
     * Obtain access to the /monitor WebSocket
     * @summary monitor ingest
     * @param {string} [enduroWsTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    ingestMonitor(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Request access to the /monitor WebSocket
     * @summary monitor_request ingest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Signal the SIP has been reviewed and rejected
     * @summary reject_sip ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Show SIP by ID
     * @summary show_sip ingest
     * @param {string} uuid Identifier of SIP to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>>;

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * @summary upload_sip ingest
     * @param {string} [contentType] Content-Type header, must define value for multipart boundary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadSipResponseBody>>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    ingestUploadSip(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadSipResponseBody>;

}

/**
 * 
 */
export class IngestApi extends runtime.BaseAPI implements IngestApiInterface {

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestConfirmSip.');
        }

        if (requestParameters.confirmSipRequestBody === null || requestParameters.confirmSipRequestBody === undefined) {
            throw new runtime.RequiredError('confirmSipRequestBody','Required parameter requestParameters.confirmSipRequestBody was null or undefined when calling ingestConfirmSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/confirm`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmSipRequestBodyToJSON(requestParameters.confirmSipRequestBody),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestConfirmSipRaw(requestParameters, initOverrides);
    }

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    async ingestDownloadSipRaw(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestDownloadSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingest/sips/{uuid}/download`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    async ingestDownloadSip(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.ingestDownloadSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    async ingestDownloadSipRequestRaw(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestDownloadSipRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/download`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    async ingestDownloadSipRequest(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestDownloadSipRequestRaw(requestParameters, initOverrides);
    }

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    async ingestListSipWorkflowsRaw(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPWorkflows>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestListSipWorkflows.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/workflows`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPWorkflowsFromJSON(jsonValue));
    }

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    async ingestListSipWorkflows(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPWorkflows> {
        const response = await this.ingestListSipWorkflowsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.aipId !== undefined) {
            queryParameters['aip_id'] = requestParameters.aipId;
        }

        if (requestParameters.earliestCreatedTime !== undefined) {
            queryParameters['earliest_created_time'] = (requestParameters.earliestCreatedTime as any).toISOString();
        }

        if (requestParameters.latestCreatedTime !== undefined) {
            queryParameters['latest_created_time'] = (requestParameters.latestCreatedTime as any).toISOString();
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.uploaderId !== undefined) {
            queryParameters['uploader_id'] = requestParameters.uploaderId;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPsFromJSON(jsonValue));
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSips(requestParameters: IngestListSipsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs> {
        const response = await this.ingestListSipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitor(requestParameters: IngestMonitorRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRaw(requestParameters, initOverrides);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRequestRaw(initOverrides);
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestRejectSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/reject`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestRejectSipRaw(requestParameters, initOverrides);
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestShowSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnduroIngestSipFromJSON(jsonValue));
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip> {
        const response = await this.ingestShowSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadSipResponseBody>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadSipResponseBodyFromJSON(jsonValue));
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSip(requestParameters: IngestUploadSipRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadSipResponseBody> {
        const response = await this.ingestUploadSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const IngestListSipsStatusEnum = {
    Error: 'error',
    Failed: 'failed',
    Queued: 'queued',
    Processing: 'processing',
    Pending: 'pending',
    Ingested: 'ingested'
} as const;
export type IngestListSipsStatusEnum = typeof IngestListSipsStatusEnum[keyof typeof IngestListSipsStatusEnum];
