/* tslint:disable */
/* eslint-disable */
/**
 * Enduro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddSipResponseBody,
  ConfirmSipRequestBody,
  EnduroIngestSip,
  IngestEvent,
  SIPNotFound,
  SIPSourceObjects,
  SIPWorkflows,
  SIPs,
  Users,
} from '../models/index';
import {
    AddSipResponseBodyFromJSON,
    AddSipResponseBodyToJSON,
    ConfirmSipRequestBodyFromJSON,
    ConfirmSipRequestBodyToJSON,
    EnduroIngestSipFromJSON,
    EnduroIngestSipToJSON,
    IngestEventFromJSON,
    IngestEventToJSON,
    SIPNotFoundFromJSON,
    SIPNotFoundToJSON,
    SIPSourceObjectsFromJSON,
    SIPSourceObjectsToJSON,
    SIPWorkflowsFromJSON,
    SIPWorkflowsToJSON,
    SIPsFromJSON,
    SIPsToJSON,
    UsersFromJSON,
    UsersToJSON,
} from '../models/index';

export interface IngestAddSipRequest {
    sourceId: string;
    key: string;
}

export interface IngestConfirmSipRequest {
    uuid: string;
    confirmSipRequestBody: ConfirmSipRequestBody;
}

export interface IngestDownloadSipRequest {
    uuid: string;
    enduroSipDownloadTicket?: string;
}

export interface IngestDownloadSipRequestRequest {
    uuid: string;
}

export interface IngestListSipSourceObjectsRequest {
    uuid: string;
    limit?: number;
    cursor?: string;
}

export interface IngestListSipWorkflowsRequest {
    uuid: string;
}

export interface IngestListSipsRequest {
    name?: string;
    aipUuid?: string;
    earliestCreatedTime?: Date;
    latestCreatedTime?: Date;
    status?: IngestListSipsStatusEnum;
    uploaderUuid?: string;
    limit?: number;
    offset?: number;
}

export interface IngestListUsersRequest {
    email?: string;
    name?: string;
    limit?: number;
    offset?: number;
}

export interface IngestMonitorRequest {
    enduroIngestWsTicket?: string;
}

export interface IngestRejectSipRequest {
    uuid: string;
}

export interface IngestShowSipRequest {
    uuid: string;
}

export interface IngestUploadSipRequest {
    contentType?: string;
}

/**
 * IngestApi - interface
 * 
 * @export
 * @interface IngestApiInterface
 */
export interface IngestApiInterface {
    /**
     * Ingest a SIP from a SIP Source
     * @summary add_sip ingest
     * @param {string} sourceId Identifier of SIP source -- CURRENTLY NOT USED
     * @param {string} key Key of the item to ingest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestAddSipRaw(requestParameters: IngestAddSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddSipResponseBody>>;

    /**
     * Ingest a SIP from a SIP Source
     * add_sip ingest
     */
    ingestAddSip(requestParameters: IngestAddSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddSipResponseBody>;

    /**
     * Signal the SIP has been reviewed and accepted
     * @summary confirm_sip ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {ConfirmSipRequestBody} confirmSipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * @summary download_sip ingest
     * @param {string} uuid Identifier of the SIP to download
     * @param {string} [enduroSipDownloadTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestDownloadSipRaw(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>>;

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    ingestDownloadSip(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob>;

    /**
     * Request access to SIP download
     * @summary download_sip_request ingest
     * @param {string} uuid Identifier of the SIP to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestDownloadSipRequestRaw(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    ingestDownloadSipRequest(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * List the objects in a SIP source
     * @summary list_sip_source_objects ingest
     * @param {string} uuid SIP source identifier -- CURRENTLY NOT USED
     * @param {number} [limit] Limit the number of results to return
     * @param {string} [cursor] Cursor token to get subsequent pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipSourceObjectsRaw(requestParameters: IngestListSipSourceObjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPSourceObjects>>;

    /**
     * List the objects in a SIP source
     * list_sip_source_objects ingest
     */
    ingestListSipSourceObjects(requestParameters: IngestListSipSourceObjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPSourceObjects>;

    /**
     * List all workflows for a SIP
     * @summary list_sip_workflows ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipWorkflowsRaw(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPWorkflows>>;

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    ingestListSipWorkflows(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPWorkflows>;

    /**
     * List all ingested SIPs
     * @summary list_sips ingest
     * @param {string} [name] 
     * @param {string} [aipUuid] Identifier of AIP
     * @param {Date} [earliestCreatedTime] 
     * @param {Date} [latestCreatedTime] 
     * @param {'error' | 'failed' | 'queued' | 'processing' | 'pending' | 'ingested'} [status] 
     * @param {string} [uploaderUuid] UUID of the SIP uploader
     * @param {number} [limit] Limit number of results to return
     * @param {number} [offset] Offset from the beginning of the found set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>>;

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    ingestListSips(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs>;

    /**
     * List all users
     * @summary list_users ingest
     * @param {string} [email] Email of the user
     * @param {string} [name] Name of the user
     * @param {number} [limit] Limit number of results to return
     * @param {number} [offset] Offset from the beginning of the found set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListUsersRaw(requestParameters: IngestListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Users>>;

    /**
     * List all users
     * list_users ingest
     */
    ingestListUsers(requestParameters: IngestListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Users>;

    /**
     * Obtain access to the /monitor WebSocket
     * @summary monitor ingest
     * @param {string} [enduroIngestWsTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    ingestMonitor(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Request access to the /monitor WebSocket
     * @summary monitor_request ingest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Signal the SIP has been reviewed and rejected
     * @summary reject_sip ingest
     * @param {string} uuid Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Show SIP by ID
     * @summary show_sip ingest
     * @param {string} uuid Identifier of SIP to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>>;

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * @summary upload_sip ingest
     * @param {string} [contentType] Content-Type header, must define value for multipart boundary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddSipResponseBody>>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    ingestUploadSip(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddSipResponseBody>;

}

/**
 * 
 */
export class IngestApi extends runtime.BaseAPI implements IngestApiInterface {

    /**
     * Ingest a SIP from a SIP Source
     * add_sip ingest
     */
    async ingestAddSipRaw(requestParameters: IngestAddSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddSipResponseBody>> {
        if (requestParameters.sourceId === null || requestParameters.sourceId === undefined) {
            throw new runtime.RequiredError('sourceId','Required parameter requestParameters.sourceId was null or undefined when calling ingestAddSip.');
        }

        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling ingestAddSip.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceId !== undefined) {
            queryParameters['source_id'] = requestParameters.sourceId;
        }

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddSipResponseBodyFromJSON(jsonValue));
    }

    /**
     * Ingest a SIP from a SIP Source
     * add_sip ingest
     */
    async ingestAddSip(requestParameters: IngestAddSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddSipResponseBody> {
        const response = await this.ingestAddSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestConfirmSip.');
        }

        if (requestParameters.confirmSipRequestBody === null || requestParameters.confirmSipRequestBody === undefined) {
            throw new runtime.RequiredError('confirmSipRequestBody','Required parameter requestParameters.confirmSipRequestBody was null or undefined when calling ingestConfirmSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/confirm`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmSipRequestBodyToJSON(requestParameters.confirmSipRequestBody),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestConfirmSipRaw(requestParameters, initOverrides);
    }

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    async ingestDownloadSipRaw(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestDownloadSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingest/sips/{uuid}/download`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download the failed package related to a SIP. It will be the original SIP or the transformed PIP, based on the SIP\'s `failed_as` value.
     * download_sip ingest
     */
    async ingestDownloadSip(requestParameters: IngestDownloadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.ingestDownloadSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    async ingestDownloadSipRequestRaw(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestDownloadSipRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/download`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Request access to SIP download
     * download_sip_request ingest
     */
    async ingestDownloadSipRequest(requestParameters: IngestDownloadSipRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestDownloadSipRequestRaw(requestParameters, initOverrides);
    }

    /**
     * List the objects in a SIP source
     * list_sip_source_objects ingest
     */
    async ingestListSipSourceObjectsRaw(requestParameters: IngestListSipSourceObjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPSourceObjects>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestListSipSourceObjects.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sip-sources/{uuid}/objects`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPSourceObjectsFromJSON(jsonValue));
    }

    /**
     * List the objects in a SIP source
     * list_sip_source_objects ingest
     */
    async ingestListSipSourceObjects(requestParameters: IngestListSipSourceObjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPSourceObjects> {
        const response = await this.ingestListSipSourceObjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    async ingestListSipWorkflowsRaw(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPWorkflows>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestListSipWorkflows.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/workflows`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPWorkflowsFromJSON(jsonValue));
    }

    /**
     * List all workflows for a SIP
     * list_sip_workflows ingest
     */
    async ingestListSipWorkflows(requestParameters: IngestListSipWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPWorkflows> {
        const response = await this.ingestListSipWorkflowsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.aipUuid !== undefined) {
            queryParameters['aip_uuid'] = requestParameters.aipUuid;
        }

        if (requestParameters.earliestCreatedTime !== undefined) {
            queryParameters['earliest_created_time'] = (requestParameters.earliestCreatedTime as any).toISOString();
        }

        if (requestParameters.latestCreatedTime !== undefined) {
            queryParameters['latest_created_time'] = (requestParameters.latestCreatedTime as any).toISOString();
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.uploaderUuid !== undefined) {
            queryParameters['uploader_uuid'] = requestParameters.uploaderUuid;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPsFromJSON(jsonValue));
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSips(requestParameters: IngestListSipsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs> {
        const response = await this.ingestListSipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all users
     * list_users ingest
     */
    async ingestListUsersRaw(requestParameters: IngestListUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Users>> {
        const queryParameters: any = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersFromJSON(jsonValue));
    }

    /**
     * List all users
     * list_users ingest
     */
    async ingestListUsers(requestParameters: IngestListUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Users> {
        const response = await this.ingestListUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitor(requestParameters: IngestMonitorRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRaw(requestParameters, initOverrides);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRequestRaw(initOverrides);
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestRejectSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}/reject`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestRejectSipRaw(requestParameters, initOverrides);
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling ingestShowSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnduroIngestSipFromJSON(jsonValue));
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip> {
        const response = await this.ingestShowSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddSipResponseBody>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddSipResponseBodyFromJSON(jsonValue));
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSip(requestParameters: IngestUploadSipRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddSipResponseBody> {
        const response = await this.ingestUploadSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const IngestListSipsStatusEnum = {
    Error: 'error',
    Failed: 'failed',
    Queued: 'queued',
    Processing: 'processing',
    Pending: 'pending',
    Ingested: 'ingested'
} as const;
export type IngestListSipsStatusEnum = typeof IngestListSipsStatusEnum[keyof typeof IngestListSipsStatusEnum];
