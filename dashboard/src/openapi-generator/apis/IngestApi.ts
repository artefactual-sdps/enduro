/* tslint:disable */
/* eslint-disable */
/**
 * Enduro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ConfirmSipRequestBody,
  EnduroIngestSip,
  MonitorEvent,
  MoveStatusResult,
  SIPNotFound,
  SIPPreservationActions,
  SIPs,
} from '../models/index';
import {
    ConfirmSipRequestBodyFromJSON,
    ConfirmSipRequestBodyToJSON,
    EnduroIngestSipFromJSON,
    EnduroIngestSipToJSON,
    MonitorEventFromJSON,
    MonitorEventToJSON,
    MoveStatusResultFromJSON,
    MoveStatusResultToJSON,
    SIPNotFoundFromJSON,
    SIPNotFoundToJSON,
    SIPPreservationActionsFromJSON,
    SIPPreservationActionsToJSON,
    SIPsFromJSON,
    SIPsToJSON,
} from '../models/index';

export interface IngestConfirmSipRequest {
    id: number;
    confirmSipRequestBody: ConfirmSipRequestBody;
}

export interface IngestListSipPreservationActionsRequest {
    id: number;
}

export interface IngestListSipsRequest {
    name?: string;
    aipId?: string;
    earliestCreatedTime?: Date;
    latestCreatedTime?: Date;
    locationId?: string;
    status?: IngestListSipsStatusEnum;
    limit?: number;
    offset?: number;
}

export interface IngestMonitorRequest {
    enduroWsTicket?: string;
}

export interface IngestMoveSipRequest {
    id: number;
    confirmSipRequestBody: ConfirmSipRequestBody;
}

export interface IngestMoveSipStatusRequest {
    id: number;
}

export interface IngestRejectSipRequest {
    id: number;
}

export interface IngestShowSipRequest {
    id: number;
}

export interface IngestUploadSipRequest {
    contentType?: string;
}

/**
 * IngestApi - interface
 * 
 * @export
 * @interface IngestApiInterface
 */
export interface IngestApiInterface {
    /**
     * Signal the SIP has been reviewed and accepted
     * @summary confirm_sip ingest
     * @param {number} id Identifier of SIP to look up
     * @param {ConfirmSipRequestBody} confirmSipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * List all preservation actions for a SIP
     * @summary list_sip_preservation_actions ingest
     * @param {number} id Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipPreservationActionsRaw(requestParameters: IngestListSipPreservationActionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPPreservationActions>>;

    /**
     * List all preservation actions for a SIP
     * list_sip_preservation_actions ingest
     */
    ingestListSipPreservationActions(requestParameters: IngestListSipPreservationActionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPPreservationActions>;

    /**
     * List all ingested SIPs
     * @summary list_sips ingest
     * @param {string} [name] 
     * @param {string} [aipId] Identifier of AIP
     * @param {Date} [earliestCreatedTime] 
     * @param {Date} [latestCreatedTime] 
     * @param {string} [locationId] Identifier of storage location
     * @param {'new' | 'in progress' | 'done' | 'error' | 'unknown' | 'queued' | 'abandoned' | 'pending'} [status] 
     * @param {number} [limit] Limit number of results to return
     * @param {number} [offset] Offset from the beginning of the found set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>>;

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    ingestListSips(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs>;

    /**
     * Obtain access to the /monitor WebSocket
     * @summary monitor ingest
     * @param {string} [enduroWsTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    ingestMonitor(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Request access to the /monitor WebSocket
     * @summary monitor_request ingest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Move a SIP to a permanent storage location
     * @summary move_sip ingest
     * @param {number} id Identifier of SIP to move
     * @param {ConfirmSipRequestBody} confirmSipRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMoveSipRaw(requestParameters: IngestMoveSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Move a SIP to a permanent storage location
     * move_sip ingest
     */
    ingestMoveSip(requestParameters: IngestMoveSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retrieve the status of a permanent storage location move of the SIP
     * @summary move_sip_status ingest
     * @param {number} id Identifier of SIP to move
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestMoveSipStatusRaw(requestParameters: IngestMoveSipStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveStatusResult>>;

    /**
     * Retrieve the status of a permanent storage location move of the SIP
     * move_sip_status ingest
     */
    ingestMoveSipStatus(requestParameters: IngestMoveSipStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveStatusResult>;

    /**
     * Signal the SIP has been reviewed and rejected
     * @summary reject_sip ingest
     * @param {number} id Identifier of SIP to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Show SIP by ID
     * @summary show_sip ingest
     * @param {number} id Identifier of SIP to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>>;

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * @summary upload_sip ingest
     * @param {string} [contentType] Content-Type header, must define value for multipart boundary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngestApiInterface
     */
    ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    ingestUploadSip(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class IngestApi extends runtime.BaseAPI implements IngestApiInterface {

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSipRaw(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestConfirmSip.');
        }

        if (requestParameters.confirmSipRequestBody === null || requestParameters.confirmSipRequestBody === undefined) {
            throw new runtime.RequiredError('confirmSipRequestBody','Required parameter requestParameters.confirmSipRequestBody was null or undefined when calling ingestConfirmSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}/confirm`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmSipRequestBodyToJSON(requestParameters.confirmSipRequestBody),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and accepted
     * confirm_sip ingest
     */
    async ingestConfirmSip(requestParameters: IngestConfirmSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestConfirmSipRaw(requestParameters, initOverrides);
    }

    /**
     * List all preservation actions for a SIP
     * list_sip_preservation_actions ingest
     */
    async ingestListSipPreservationActionsRaw(requestParameters: IngestListSipPreservationActionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPPreservationActions>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestListSipPreservationActions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}/preservation-actions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPPreservationActionsFromJSON(jsonValue));
    }

    /**
     * List all preservation actions for a SIP
     * list_sip_preservation_actions ingest
     */
    async ingestListSipPreservationActions(requestParameters: IngestListSipPreservationActionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPPreservationActions> {
        const response = await this.ingestListSipPreservationActionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSipsRaw(requestParameters: IngestListSipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SIPs>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.aipId !== undefined) {
            queryParameters['aip_id'] = requestParameters.aipId;
        }

        if (requestParameters.earliestCreatedTime !== undefined) {
            queryParameters['earliest_created_time'] = (requestParameters.earliestCreatedTime as any).toISOString();
        }

        if (requestParameters.latestCreatedTime !== undefined) {
            queryParameters['latest_created_time'] = (requestParameters.latestCreatedTime as any).toISOString();
        }

        if (requestParameters.locationId !== undefined) {
            queryParameters['location_id'] = requestParameters.locationId;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SIPsFromJSON(jsonValue));
    }

    /**
     * List all ingested SIPs
     * list_sips ingest
     */
    async ingestListSips(requestParameters: IngestListSipsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SIPs> {
        const response = await this.ingestListSipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitorRaw(requestParameters: IngestMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Obtain access to the /monitor WebSocket
     * monitor ingest
     */
    async ingestMonitor(requestParameters: IngestMonitorRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRaw(requestParameters, initOverrides);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequestRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/monitor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Request access to the /monitor WebSocket
     * monitor_request ingest
     */
    async ingestMonitorRequest(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMonitorRequestRaw(initOverrides);
    }

    /**
     * Move a SIP to a permanent storage location
     * move_sip ingest
     */
    async ingestMoveSipRaw(requestParameters: IngestMoveSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestMoveSip.');
        }

        if (requestParameters.confirmSipRequestBody === null || requestParameters.confirmSipRequestBody === undefined) {
            throw new runtime.RequiredError('confirmSipRequestBody','Required parameter requestParameters.confirmSipRequestBody was null or undefined when calling ingestMoveSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}/move`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConfirmSipRequestBodyToJSON(requestParameters.confirmSipRequestBody),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Move a SIP to a permanent storage location
     * move_sip ingest
     */
    async ingestMoveSip(requestParameters: IngestMoveSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestMoveSipRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the status of a permanent storage location move of the SIP
     * move_sip_status ingest
     */
    async ingestMoveSipStatusRaw(requestParameters: IngestMoveSipStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveStatusResult>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestMoveSipStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}/move`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MoveStatusResultFromJSON(jsonValue));
    }

    /**
     * Retrieve the status of a permanent storage location move of the SIP
     * move_sip_status ingest
     */
    async ingestMoveSipStatus(requestParameters: IngestMoveSipStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveStatusResult> {
        const response = await this.ingestMoveSipStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSipRaw(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestRejectSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}/reject`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Signal the SIP has been reviewed and rejected
     * reject_sip ingest
     */
    async ingestRejectSip(requestParameters: IngestRejectSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestRejectSipRaw(requestParameters, initOverrides);
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSipRaw(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroIngestSip>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling ingestShowSip.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnduroIngestSipFromJSON(jsonValue));
    }

    /**
     * Show SIP by ID
     * show_sip ingest
     */
    async ingestShowSip(requestParameters: IngestShowSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroIngestSip> {
        const response = await this.ingestShowSipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSipRaw(requestParameters: IngestUploadSipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("jwt_header_Authorization", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/ingest/sips/upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Upload a SIP to trigger an ingest workflow
     * upload_sip ingest
     */
    async ingestUploadSip(requestParameters: IngestUploadSipRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.ingestUploadSipRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const IngestListSipsStatusEnum = {
    New: 'new',
    InProgress: 'in progress',
    Done: 'done',
    Error: 'error',
    Unknown: 'unknown',
    Queued: 'queued',
    Abandoned: 'abandoned',
    Pending: 'pending'
} as const;
export type IngestListSipsStatusEnum = typeof IngestListSipsStatusEnum[keyof typeof IngestListSipsStatusEnum];
