package entclient

import (
	"context"
	"time"

	"github.com/go-logr/logr"
	"github.com/google/uuid"

	"github.com/artefactual-sdps/enduro/internal/datatypes"
	"github.com/artefactual-sdps/enduro/internal/persistence"
	"github.com/artefactual-sdps/enduro/internal/persistence/ent/db"
)

type client struct {
	logger logr.Logger
	ent    *db.Client
}

var _ persistence.Service = (*client)(nil)

// New returns a new ent client that implements the persistence service.
func New(logger logr.Logger, ent *db.Client) persistence.Service {
	return &client{logger: logger, ent: ent}
}

// CreatePackage creates and persists a new package using the values from pkg
// then returns the updated package.
//
// The input pkg "ID" and "CreatedAt" values are ignored; the stored package
// "ID" is generated by the persistence implementation and "CreatedAt" is always
// set to the current time.
func (c *client) CreatePackage(ctx context.Context, pkg *datatypes.Package) error {
	// Validate required fields.
	if pkg.Name == "" {
		return newRequiredFieldError("Name")
	}
	if pkg.WorkflowID == "" {
		return newRequiredFieldError("WorkflowID")
	}

	if pkg.RunID == "" {
		return newRequiredFieldError("RunID")
	}
	runID, err := uuid.Parse(pkg.RunID)
	if err != nil {
		return newParseError(err, "RunID")
	}

	q := c.ent.Pkg.Create().
		SetName(pkg.Name).
		SetWorkflowID(pkg.WorkflowID).
		SetRunID(runID).
		SetStatus(int8(pkg.Status))

	// Add optional fields.
	if pkg.AIPID.Valid {
		q.SetAipID(pkg.AIPID.UUID)
	}
	if pkg.LocationID.Valid {
		q.SetLocationID(pkg.LocationID.UUID)
	}
	if pkg.StartedAt.Valid {
		q.SetStartedAt(pkg.StartedAt.Time)
	}
	if pkg.CompletedAt.Valid {
		q.SetCompletedAt(pkg.CompletedAt.Time)
	}

	// Set CreatedAt to the current time
	q.SetCreatedAt(time.Now())

	// Save the package.
	p, err := q.Save(ctx)
	if err != nil {
		return newDBErrorWithDetails(err, "create package")
	}

	// Update pkg with DB data, to get generated values (e.g. ID).
	*pkg = *convertPkgToPackage(p)

	return nil
}

// UpdatePackage updates the persisted package identified by id using the
// updater function, then returns the updated package.
//
// The package "ID" and "CreatedAt" field values can not be updated with this
// method.
func (c *client) UpdatePackage(
	ctx context.Context,
	id uint,
	updater persistence.PackageUpdater,
) (*datatypes.Package, error) {
	tx, err := c.ent.BeginTx(ctx, nil)
	if err != nil {
		return nil, newDBError(err)
	}

	p, err := tx.Pkg.Get(ctx, int(id))
	if err != nil {
		return nil, rollback(tx, newDBError(err))
	}

	up, err := updater(convertPkgToPackage(p))
	if err != nil {
		return nil, rollback(tx, newUpdaterError(err))
	}

	runID, err := uuid.Parse(up.RunID)
	if err != nil {
		return nil, rollback(tx, newParseError(err, "RunID"))
	}

	// Set required column values.
	q := tx.Pkg.UpdateOneID(int(id)).
		SetName(up.Name).
		SetWorkflowID(up.WorkflowID).
		SetRunID(runID).
		SetStatus(int8(up.Status))

	// Set nullable column values.
	if up.AIPID.Valid {
		q.SetAipID(up.AIPID.UUID)
	}
	if up.LocationID.Valid {
		q.SetLocationID(up.LocationID.UUID)
	}
	if up.StartedAt.Valid {
		q.SetStartedAt(up.StartedAt.Time)
	}
	if up.CompletedAt.Valid {
		q.SetCompletedAt(up.CompletedAt.Time)
	}

	// Save changes.
	p, err = q.Save(ctx)
	if err != nil {
		return nil, rollback(tx, newDBError(err))
	}
	if err = tx.Commit(); err != nil {
		return nil, rollback(tx, newDBError(err))
	}

	return convertPkgToPackage(p), nil
}
