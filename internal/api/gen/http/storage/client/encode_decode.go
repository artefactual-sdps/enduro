// Code generated by goa v3.15.2, DO NOT EDIT.
//
// storage HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/artefactual-sdps/enduro/internal/api/design -o
// internal/api

package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	storage "github.com/artefactual-sdps/enduro/internal/api/gen/storage"
	storageviews "github.com/artefactual-sdps/enduro/internal/api/gen/storage/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildListAipsRequest instantiates a HTTP request object with method and path
// set to call the "storage" service "list_aips" endpoint
func (c *Client) BuildListAipsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListAipsStoragePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "list_aips", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListAipsRequest returns an encoder for requests sent to the storage
// list_aips server.
func EncodeListAipsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ListAipsPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "list_aips", "*storage.ListAipsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		if p.EarliestCreatedTime != nil {
			values.Add("earliest_created_time", *p.EarliestCreatedTime)
		}
		if p.LatestCreatedTime != nil {
			values.Add("latest_created_time", *p.LatestCreatedTime)
		}
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.Limit != nil {
			values.Add("limit", fmt.Sprintf("%v", *p.Limit))
		}
		if p.Offset != nil {
			values.Add("offset", fmt.Sprintf("%v", *p.Offset))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListAipsResponse returns a decoder for responses returned by the
// storage list_aips endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeListAipsResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListAipsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListAipsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aips", err)
			}
			p := NewListAipsAIPsOK(&body)
			view := "default"
			vres := &storageviews.AIPs{Projected: p, View: view}
			if err = storageviews.ValidateAIPs(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_aips", err)
			}
			res := storage.NewAIPs(vres)
			return res, nil
		case http.StatusConflict:
			var (
				body ListAipsNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aips", err)
			}
			err = ValidateListAipsNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_aips", err)
			}
			return nil, NewListAipsNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body ListAipsNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aips", err)
			}
			err = ValidateListAipsNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_aips", err)
			}
			return nil, NewListAipsNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aips", err)
			}
			return nil, NewListAipsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aips", err)
			}
			return nil, NewListAipsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "list_aips", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateAipRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "create_aip" endpoint
func (c *Client) BuildCreateAipRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateAipStoragePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "create_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateAipRequest returns an encoder for requests sent to the storage
// create_aip server.
func EncodeCreateAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.CreateAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "create_aip", "*storage.CreateAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreateAipRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "create_aip", err)
		}
		return nil
	}
}

// DecodeCreateAipResponse returns a decoder for responses returned by the
// storage create_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCreateAipResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateAipResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_aip", err)
			}
			p := NewCreateAipAIPOK(&body)
			view := "default"
			vres := &storageviews.AIP{Projected: p, View: view}
			if err = storageviews.ValidateAIP(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "create_aip", err)
			}
			res := storage.NewAIP(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_aip", err)
			}
			err = ValidateCreateAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "create_aip", err)
			}
			return nil, NewCreateAipNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_aip", err)
			}
			return nil, NewCreateAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_aip", err)
			}
			return nil, NewCreateAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "create_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildSubmitAipRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "submit_aip" endpoint
func (c *Client) BuildSubmitAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.SubmitAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "submit_aip", "*storage.SubmitAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SubmitAipStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "submit_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSubmitAipRequest returns an encoder for requests sent to the storage
// submit_aip server.
func EncodeSubmitAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.SubmitAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "submit_aip", "*storage.SubmitAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewSubmitAipRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "submit_aip", err)
		}
		return nil
	}
}

// DecodeSubmitAipResponse returns a decoder for responses returned by the
// storage submit_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeSubmitAipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeSubmitAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			var (
				body SubmitAipResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "submit_aip", err)
			}
			err = ValidateSubmitAipResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "submit_aip", err)
			}
			res := NewSubmitAipSubmitAIPResultAccepted(&body)
			return res, nil
		case http.StatusConflict:
			var (
				body SubmitAipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "submit_aip", err)
			}
			err = ValidateSubmitAipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "submit_aip", err)
			}
			return nil, NewSubmitAipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body SubmitAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "submit_aip", err)
			}
			err = ValidateSubmitAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "submit_aip", err)
			}
			return nil, NewSubmitAipNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "submit_aip", err)
			}
			return nil, NewSubmitAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "submit_aip", err)
			}
			return nil, NewSubmitAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "submit_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateAipRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "update_aip" endpoint
func (c *Client) BuildUpdateAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.UpdateAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "update_aip", "*storage.UpdateAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateAipStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "update_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateAipRequest returns an encoder for requests sent to the storage
// update_aip server.
func EncodeUpdateAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.UpdateAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "update_aip", "*storage.UpdateAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeUpdateAipResponse returns a decoder for responses returned by the
// storage update_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateAipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeUpdateAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusConflict:
			var (
				body UpdateAipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "update_aip", err)
			}
			err = ValidateUpdateAipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "update_aip", err)
			}
			return nil, NewUpdateAipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body UpdateAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "update_aip", err)
			}
			err = ValidateUpdateAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "update_aip", err)
			}
			return nil, NewUpdateAipNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "update_aip", err)
			}
			return nil, NewUpdateAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "update_aip", err)
			}
			return nil, NewUpdateAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "update_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildDownloadAipRequestRequest instantiates a HTTP request object with
// method and path set to call the "storage" service "download_aip_request"
// endpoint
func (c *Client) BuildDownloadAipRequestRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.DownloadAipRequestPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "download_aip_request", "*storage.DownloadAipRequestPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DownloadAipRequestStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "download_aip_request", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDownloadAipRequestRequest returns an encoder for requests sent to the
// storage download_aip_request server.
func EncodeDownloadAipRequestRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.DownloadAipRequestPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "download_aip_request", "*storage.DownloadAipRequestPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDownloadAipRequestResponse returns a decoder for responses returned by
// the storage download_aip_request endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDownloadAipRequestResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "internal_error" (type *goa.ServiceError): http.StatusInternalServerError
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeDownloadAipRequestResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				ticket    *string
				ticketRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "enduro-aip-download-ticket":
					ticketRaw = c.Value
				}
			}
			if ticketRaw != "" {
				ticket = &ticketRaw
			}
			res := NewDownloadAipRequestResultOK(ticket)
			return res, nil
		case http.StatusBadRequest:
			var (
				body DownloadAipRequestNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip_request", err)
			}
			err = ValidateDownloadAipRequestNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip_request", err)
			}
			return nil, NewDownloadAipRequestNotValid(&body)
		case http.StatusInternalServerError:
			var (
				body DownloadAipRequestInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip_request", err)
			}
			err = ValidateDownloadAipRequestInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip_request", err)
			}
			return nil, NewDownloadAipRequestInternalError(&body)
		case http.StatusNotFound:
			var (
				body DownloadAipRequestNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip_request", err)
			}
			err = ValidateDownloadAipRequestNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip_request", err)
			}
			return nil, NewDownloadAipRequestNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip_request", err)
			}
			return nil, NewDownloadAipRequestForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip_request", err)
			}
			return nil, NewDownloadAipRequestUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "download_aip_request", resp.StatusCode, string(body))
		}
	}
}

// BuildDownloadAipRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "download_aip" endpoint
func (c *Client) BuildDownloadAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.DownloadAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "download_aip", "*storage.DownloadAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DownloadAipStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "download_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDownloadAipRequest returns an encoder for requests sent to the storage
// download_aip server.
func EncodeDownloadAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.DownloadAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "download_aip", "*storage.DownloadAipPayload", v)
		}
		if p.Ticket != nil {
			v := *p.Ticket
			req.AddCookie(&http.Cookie{
				Name:  "enduro-aip-download-ticket",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeDownloadAipResponse returns a decoder for responses returned by the
// storage download_aip endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeDownloadAipResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "internal_error" (type *goa.ServiceError): http.StatusInternalServerError
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeDownloadAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				contentType        string
				contentLength      int64
				contentDisposition string
				err                error
			)
			contentTypeRaw := resp.Header.Get("Content-Type")
			if contentTypeRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("content_type", "header"))
			}
			contentType = contentTypeRaw
			{
				contentLengthRaw := resp.Header.Get("Content-Length")
				if contentLengthRaw == "" {
					return nil, goahttp.ErrValidationError("storage", "download_aip", goa.MissingFieldError("content_length", "header"))
				}
				v, err2 := strconv.ParseInt(contentLengthRaw, 10, 64)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("content_length", contentLengthRaw, "integer"))
				}
				contentLength = v
			}
			contentDispositionRaw := resp.Header.Get("Content-Disposition")
			if contentDispositionRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("content_disposition", "header"))
			}
			contentDisposition = contentDispositionRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip", err)
			}
			res := NewDownloadAipResultOK(contentType, contentLength, contentDisposition)
			return res, nil
		case http.StatusBadRequest:
			var (
				body DownloadAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip", err)
			}
			err = ValidateDownloadAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip", err)
			}
			return nil, NewDownloadAipNotValid(&body)
		case http.StatusInternalServerError:
			var (
				body DownloadAipInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip", err)
			}
			err = ValidateDownloadAipInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip", err)
			}
			return nil, NewDownloadAipInternalError(&body)
		case http.StatusNotFound:
			var (
				body DownloadAipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip", err)
			}
			err = ValidateDownloadAipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "download_aip", err)
			}
			return nil, NewDownloadAipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip", err)
			}
			return nil, NewDownloadAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "download_aip", err)
			}
			return nil, NewDownloadAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "download_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildMoveAipRequest instantiates a HTTP request object with method and path
// set to call the "storage" service "move_aip" endpoint
func (c *Client) BuildMoveAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.MoveAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "move_aip", "*storage.MoveAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: MoveAipStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "move_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeMoveAipRequest returns an encoder for requests sent to the storage
// move_aip server.
func EncodeMoveAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.MoveAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "move_aip", "*storage.MoveAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewMoveAipRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "move_aip", err)
		}
		return nil
	}
}

// DecodeMoveAipResponse returns a decoder for responses returned by the
// storage move_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeMoveAipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeMoveAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusConflict:
			var (
				body MoveAipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip", err)
			}
			err = ValidateMoveAipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip", err)
			}
			return nil, NewMoveAipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body MoveAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip", err)
			}
			err = ValidateMoveAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip", err)
			}
			return nil, NewMoveAipNotValid(&body)
		case http.StatusNotFound:
			var (
				body MoveAipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip", err)
			}
			err = ValidateMoveAipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip", err)
			}
			return nil, NewMoveAipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip", err)
			}
			return nil, NewMoveAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip", err)
			}
			return nil, NewMoveAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "move_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildMoveAipStatusRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "move_aip_status" endpoint
func (c *Client) BuildMoveAipStatusRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.MoveAipStatusPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "move_aip_status", "*storage.MoveAipStatusPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: MoveAipStatusStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "move_aip_status", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeMoveAipStatusRequest returns an encoder for requests sent to the
// storage move_aip_status server.
func EncodeMoveAipStatusRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.MoveAipStatusPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "move_aip_status", "*storage.MoveAipStatusPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeMoveAipStatusResponse returns a decoder for responses returned by the
// storage move_aip_status endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeMoveAipStatusResponse may return the following errors:
//   - "failed_dependency" (type *goa.ServiceError): http.StatusFailedDependency
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeMoveAipStatusResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body MoveAipStatusResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip_status", err)
			}
			err = ValidateMoveAipStatusResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip_status", err)
			}
			res := NewMoveAipStatusMoveStatusResultOK(&body)
			return res, nil
		case http.StatusFailedDependency:
			var (
				body MoveAipStatusFailedDependencyResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip_status", err)
			}
			err = ValidateMoveAipStatusFailedDependencyResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip_status", err)
			}
			return nil, NewMoveAipStatusFailedDependency(&body)
		case http.StatusNotFound:
			var (
				body MoveAipStatusNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip_status", err)
			}
			err = ValidateMoveAipStatusNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "move_aip_status", err)
			}
			return nil, NewMoveAipStatusNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip_status", err)
			}
			return nil, NewMoveAipStatusForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "move_aip_status", err)
			}
			return nil, NewMoveAipStatusUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "move_aip_status", resp.StatusCode, string(body))
		}
	}
}

// BuildRejectAipRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "reject_aip" endpoint
func (c *Client) BuildRejectAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.RejectAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "reject_aip", "*storage.RejectAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RejectAipStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "reject_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRejectAipRequest returns an encoder for requests sent to the storage
// reject_aip server.
func EncodeRejectAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.RejectAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "reject_aip", "*storage.RejectAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeRejectAipResponse returns a decoder for responses returned by the
// storage reject_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeRejectAipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeRejectAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusConflict:
			var (
				body RejectAipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "reject_aip", err)
			}
			err = ValidateRejectAipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "reject_aip", err)
			}
			return nil, NewRejectAipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body RejectAipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "reject_aip", err)
			}
			err = ValidateRejectAipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "reject_aip", err)
			}
			return nil, NewRejectAipNotValid(&body)
		case http.StatusNotFound:
			var (
				body RejectAipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "reject_aip", err)
			}
			err = ValidateRejectAipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "reject_aip", err)
			}
			return nil, NewRejectAipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "reject_aip", err)
			}
			return nil, NewRejectAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "reject_aip", err)
			}
			return nil, NewRejectAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "reject_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildShowAipRequest instantiates a HTTP request object with method and path
// set to call the "storage" service "show_aip" endpoint
func (c *Client) BuildShowAipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.ShowAipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "show_aip", "*storage.ShowAipPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ShowAipStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "show_aip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeShowAipRequest returns an encoder for requests sent to the storage
// show_aip server.
func EncodeShowAipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ShowAipPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "show_aip", "*storage.ShowAipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeShowAipResponse returns a decoder for responses returned by the
// storage show_aip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeShowAipResponse may return the following errors:
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeShowAipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ShowAipResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_aip", err)
			}
			p := NewShowAipAIPOK(&body)
			view := "default"
			vres := &storageviews.AIP{Projected: p, View: view}
			if err = storageviews.ValidateAIP(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "show_aip", err)
			}
			res := storage.NewAIP(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ShowAipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_aip", err)
			}
			err = ValidateShowAipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "show_aip", err)
			}
			return nil, NewShowAipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_aip", err)
			}
			return nil, NewShowAipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_aip", err)
			}
			return nil, NewShowAipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "show_aip", resp.StatusCode, string(body))
		}
	}
}

// BuildListAipWorkflowsRequest instantiates a HTTP request object with method
// and path set to call the "storage" service "list_aip_workflows" endpoint
func (c *Client) BuildListAipWorkflowsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.ListAipWorkflowsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "list_aip_workflows", "*storage.ListAipWorkflowsPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListAipWorkflowsStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "list_aip_workflows", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListAipWorkflowsRequest returns an encoder for requests sent to the
// storage list_aip_workflows server.
func EncodeListAipWorkflowsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ListAipWorkflowsPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "list_aip_workflows", "*storage.ListAipWorkflowsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.Type != nil {
			values.Add("type", *p.Type)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListAipWorkflowsResponse returns a decoder for responses returned by
// the storage list_aip_workflows endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListAipWorkflowsResponse may return the following errors:
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListAipWorkflowsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListAipWorkflowsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aip_workflows", err)
			}
			p := NewListAipWorkflowsAIPWorkflowsOK(&body)
			view := "default"
			vres := &storageviews.AIPWorkflows{Projected: p, View: view}
			if err = storageviews.ValidateAIPWorkflows(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_aip_workflows", err)
			}
			res := storage.NewAIPWorkflows(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListAipWorkflowsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aip_workflows", err)
			}
			err = ValidateListAipWorkflowsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_aip_workflows", err)
			}
			return nil, NewListAipWorkflowsNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aip_workflows", err)
			}
			return nil, NewListAipWorkflowsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_aip_workflows", err)
			}
			return nil, NewListAipWorkflowsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "list_aip_workflows", resp.StatusCode, string(body))
		}
	}
}

// BuildRequestAipDeletionRequest instantiates a HTTP request object with
// method and path set to call the "storage" service "request_aip_deletion"
// endpoint
func (c *Client) BuildRequestAipDeletionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.RequestAipDeletionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "request_aip_deletion", "*storage.RequestAipDeletionPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RequestAipDeletionStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "request_aip_deletion", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRequestAipDeletionRequest returns an encoder for requests sent to the
// storage request_aip_deletion server.
func EncodeRequestAipDeletionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.RequestAipDeletionPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "request_aip_deletion", "*storage.RequestAipDeletionPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewRequestAipDeletionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "request_aip_deletion", err)
		}
		return nil
	}
}

// DecodeRequestAipDeletionResponse returns a decoder for responses returned by
// the storage request_aip_deletion endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeRequestAipDeletionResponse may return the following errors:
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeRequestAipDeletionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body RequestAipDeletionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "request_aip_deletion", err)
			}
			err = ValidateRequestAipDeletionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "request_aip_deletion", err)
			}
			return nil, NewRequestAipDeletionNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "request_aip_deletion", err)
			}
			return nil, NewRequestAipDeletionForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "request_aip_deletion", err)
			}
			return nil, NewRequestAipDeletionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "request_aip_deletion", resp.StatusCode, string(body))
		}
	}
}

// BuildReviewAipDeletionRequest instantiates a HTTP request object with method
// and path set to call the "storage" service "review_aip_deletion" endpoint
func (c *Client) BuildReviewAipDeletionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.ReviewAipDeletionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "review_aip_deletion", "*storage.ReviewAipDeletionPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReviewAipDeletionStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "review_aip_deletion", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeReviewAipDeletionRequest returns an encoder for requests sent to the
// storage review_aip_deletion server.
func EncodeReviewAipDeletionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ReviewAipDeletionPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "review_aip_deletion", "*storage.ReviewAipDeletionPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewReviewAipDeletionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "review_aip_deletion", err)
		}
		return nil
	}
}

// DecodeReviewAipDeletionResponse returns a decoder for responses returned by
// the storage review_aip_deletion endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeReviewAipDeletionResponse may return the following errors:
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeReviewAipDeletionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body ReviewAipDeletionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "review_aip_deletion", err)
			}
			err = ValidateReviewAipDeletionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "review_aip_deletion", err)
			}
			return nil, NewReviewAipDeletionNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "review_aip_deletion", err)
			}
			return nil, NewReviewAipDeletionForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "review_aip_deletion", err)
			}
			return nil, NewReviewAipDeletionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "review_aip_deletion", resp.StatusCode, string(body))
		}
	}
}

// BuildCancelAipDeletionRequest instantiates a HTTP request object with method
// and path set to call the "storage" service "cancel_aip_deletion" endpoint
func (c *Client) BuildCancelAipDeletionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.CancelAipDeletionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "cancel_aip_deletion", "*storage.CancelAipDeletionPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CancelAipDeletionStoragePath(uuid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "cancel_aip_deletion", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCancelAipDeletionRequest returns an encoder for requests sent to the
// storage cancel_aip_deletion server.
func EncodeCancelAipDeletionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.CancelAipDeletionPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "cancel_aip_deletion", "*storage.CancelAipDeletionPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCancelAipDeletionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "cancel_aip_deletion", err)
		}
		return nil
	}
}

// DecodeCancelAipDeletionResponse returns a decoder for responses returned by
// the storage cancel_aip_deletion endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCancelAipDeletionResponse may return the following errors:
//   - "not_found" (type *storage.AIPNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCancelAipDeletionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusNotFound:
			var (
				body CancelAipDeletionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "cancel_aip_deletion", err)
			}
			err = ValidateCancelAipDeletionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "cancel_aip_deletion", err)
			}
			return nil, NewCancelAipDeletionNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "cancel_aip_deletion", err)
			}
			return nil, NewCancelAipDeletionForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "cancel_aip_deletion", err)
			}
			return nil, NewCancelAipDeletionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "cancel_aip_deletion", resp.StatusCode, string(body))
		}
	}
}

// BuildListLocationsRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "list_locations" endpoint
func (c *Client) BuildListLocationsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListLocationsStoragePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "list_locations", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListLocationsRequest returns an encoder for requests sent to the
// storage list_locations server.
func EncodeListLocationsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ListLocationsPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "list_locations", "*storage.ListLocationsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListLocationsResponse returns a decoder for responses returned by the
// storage list_locations endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListLocationsResponse may return the following errors:
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListLocationsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListLocationsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_locations", err)
			}
			p := NewListLocationsLocationCollectionOK(body)
			view := "default"
			vres := storageviews.LocationCollection{Projected: p, View: view}
			if err = storageviews.ValidateLocationCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_locations", err)
			}
			res := storage.NewLocationCollection(vres)
			return res, nil
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_locations", err)
			}
			return nil, NewListLocationsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_locations", err)
			}
			return nil, NewListLocationsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "list_locations", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateLocationRequest instantiates a HTTP request object with method
// and path set to call the "storage" service "create_location" endpoint
func (c *Client) BuildCreateLocationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateLocationStoragePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "create_location", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateLocationRequest returns an encoder for requests sent to the
// storage create_location server.
func EncodeCreateLocationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.CreateLocationPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "create_location", "*storage.CreateLocationPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreateLocationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("storage", "create_location", err)
		}
		return nil
	}
}

// DecodeCreateLocationResponse returns a decoder for responses returned by the
// storage create_location endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeCreateLocationResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateLocationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateLocationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_location", err)
			}
			err = ValidateCreateLocationResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "create_location", err)
			}
			res := NewCreateLocationResultCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateLocationNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_location", err)
			}
			err = ValidateCreateLocationNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "create_location", err)
			}
			return nil, NewCreateLocationNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_location", err)
			}
			return nil, NewCreateLocationForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "create_location", err)
			}
			return nil, NewCreateLocationUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "create_location", resp.StatusCode, string(body))
		}
	}
}

// BuildShowLocationRequest instantiates a HTTP request object with method and
// path set to call the "storage" service "show_location" endpoint
func (c *Client) BuildShowLocationRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.ShowLocationPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "show_location", "*storage.ShowLocationPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ShowLocationStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "show_location", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeShowLocationRequest returns an encoder for requests sent to the
// storage show_location server.
func EncodeShowLocationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ShowLocationPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "show_location", "*storage.ShowLocationPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeShowLocationResponse returns a decoder for responses returned by the
// storage show_location endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeShowLocationResponse may return the following errors:
//   - "not_found" (type *storage.LocationNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeShowLocationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ShowLocationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_location", err)
			}
			p := NewShowLocationLocationOK(&body)
			view := "default"
			vres := &storageviews.Location{Projected: p, View: view}
			if err = storageviews.ValidateLocation(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "show_location", err)
			}
			res := storage.NewLocation(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ShowLocationNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_location", err)
			}
			err = ValidateShowLocationNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "show_location", err)
			}
			return nil, NewShowLocationNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_location", err)
			}
			return nil, NewShowLocationForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "show_location", err)
			}
			return nil, NewShowLocationUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "show_location", resp.StatusCode, string(body))
		}
	}
}

// BuildListLocationAipsRequest instantiates a HTTP request object with method
// and path set to call the "storage" service "list_location_aips" endpoint
func (c *Client) BuildListLocationAipsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*storage.ListLocationAipsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("storage", "list_location_aips", "*storage.ListLocationAipsPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListLocationAipsStoragePath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("storage", "list_location_aips", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListLocationAipsRequest returns an encoder for requests sent to the
// storage list_location_aips server.
func EncodeListLocationAipsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*storage.ListLocationAipsPayload)
		if !ok {
			return goahttp.ErrInvalidType("storage", "list_location_aips", "*storage.ListLocationAipsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListLocationAipsResponse returns a decoder for responses returned by
// the storage list_location_aips endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListLocationAipsResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *storage.LocationNotFound): http.StatusNotFound
//   - "forbidden" (type storage.Forbidden): http.StatusForbidden
//   - "unauthorized" (type storage.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListLocationAipsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListLocationAipsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_location_aips", err)
			}
			p := NewListLocationAipsAIPCollectionOK(body)
			view := "default"
			vres := storageviews.AIPCollection{Projected: p, View: view}
			if err = storageviews.ValidateAIPCollection(vres); err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_location_aips", err)
			}
			res := storage.NewAIPCollection(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListLocationAipsNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_location_aips", err)
			}
			err = ValidateListLocationAipsNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_location_aips", err)
			}
			return nil, NewListLocationAipsNotValid(&body)
		case http.StatusNotFound:
			var (
				body ListLocationAipsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_location_aips", err)
			}
			err = ValidateListLocationAipsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("storage", "list_location_aips", err)
			}
			return nil, NewListLocationAipsNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_location_aips", err)
			}
			return nil, NewListLocationAipsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("storage", "list_location_aips", err)
			}
			return nil, NewListLocationAipsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("storage", "list_location_aips", resp.StatusCode, string(body))
		}
	}
}

// unmarshalAIPResponseBodyToStorageviewsAIPView builds a value of type
// *storageviews.AIPView from a value of type *AIPResponseBody.
func unmarshalAIPResponseBodyToStorageviewsAIPView(v *AIPResponseBody) *storageviews.AIPView {
	res := &storageviews.AIPView{
		Name:       v.Name,
		UUID:       v.UUID,
		Status:     v.Status,
		ObjectKey:  v.ObjectKey,
		LocationID: v.LocationID,
		CreatedAt:  v.CreatedAt,
	}

	return res
}

// unmarshalEnduroPageResponseBodyToStorageviewsEnduroPageView builds a value
// of type *storageviews.EnduroPageView from a value of type
// *EnduroPageResponseBody.
func unmarshalEnduroPageResponseBodyToStorageviewsEnduroPageView(v *EnduroPageResponseBody) *storageviews.EnduroPageView {
	res := &storageviews.EnduroPageView{
		Limit:  v.Limit,
		Offset: v.Offset,
		Total:  v.Total,
	}

	return res
}

// unmarshalAIPWorkflowResponseBodyToStorageviewsAIPWorkflowView builds a value
// of type *storageviews.AIPWorkflowView from a value of type
// *AIPWorkflowResponseBody.
func unmarshalAIPWorkflowResponseBodyToStorageviewsAIPWorkflowView(v *AIPWorkflowResponseBody) *storageviews.AIPWorkflowView {
	if v == nil {
		return nil
	}
	res := &storageviews.AIPWorkflowView{
		UUID:        v.UUID,
		TemporalID:  v.TemporalID,
		Type:        v.Type,
		Status:      v.Status,
		StartedAt:   v.StartedAt,
		CompletedAt: v.CompletedAt,
	}
	if v.Tasks != nil {
		res.Tasks = make([]*storageviews.AIPTaskView, len(v.Tasks))
		for i, val := range v.Tasks {
			res.Tasks[i] = unmarshalAIPTaskResponseBodyToStorageviewsAIPTaskView(val)
		}
	}

	return res
}

// unmarshalAIPTaskResponseBodyToStorageviewsAIPTaskView builds a value of type
// *storageviews.AIPTaskView from a value of type *AIPTaskResponseBody.
func unmarshalAIPTaskResponseBodyToStorageviewsAIPTaskView(v *AIPTaskResponseBody) *storageviews.AIPTaskView {
	if v == nil {
		return nil
	}
	res := &storageviews.AIPTaskView{
		UUID:        v.UUID,
		Name:        v.Name,
		Status:      v.Status,
		StartedAt:   v.StartedAt,
		CompletedAt: v.CompletedAt,
		Note:        v.Note,
	}

	return res
}

// unmarshalLocationResponseToStorageviewsLocationView builds a value of type
// *storageviews.LocationView from a value of type *LocationResponse.
func unmarshalLocationResponseToStorageviewsLocationView(v *LocationResponse) *storageviews.LocationView {
	res := &storageviews.LocationView{
		Name:        v.Name,
		Description: v.Description,
		Source:      v.Source,
		Purpose:     v.Purpose,
		UUID:        v.UUID,
		CreatedAt:   v.CreatedAt,
	}
	if v.Config != nil {
		switch *v.Config.Type {
		case "amss":
			var val *storageviews.AMSSConfigView
			json.Unmarshal([]byte(*v.Config.Value), &val)
			res.Config = val
		case "s3":
			var val *storageviews.S3ConfigView
			json.Unmarshal([]byte(*v.Config.Value), &val)
			res.Config = val
		case "sftp":
			var val *storageviews.SFTPConfigView
			json.Unmarshal([]byte(*v.Config.Value), &val)
			res.Config = val
		case "url":
			var val *storageviews.URLConfigView
			json.Unmarshal([]byte(*v.Config.Value), &val)
			res.Config = val
		}
	}

	return res
}

// unmarshalAIPResponseToStorageviewsAIPView builds a value of type
// *storageviews.AIPView from a value of type *AIPResponse.
func unmarshalAIPResponseToStorageviewsAIPView(v *AIPResponse) *storageviews.AIPView {
	res := &storageviews.AIPView{
		Name:       v.Name,
		UUID:       v.UUID,
		Status:     v.Status,
		ObjectKey:  v.ObjectKey,
		LocationID: v.LocationID,
		CreatedAt:  v.CreatedAt,
	}

	return res
}
