// Code generated by goa v3.22.2, DO NOT EDIT.
//
// storage HTTP server
//
// Command:
// $ goa gen github.com/artefactual-sdps/enduro/internal/api/design -o
// internal/api

package server

import (
	"bufio"
	"context"
	"io"
	"net/http"
	"os"

	storage "github.com/artefactual-sdps/enduro/internal/api/gen/storage"
	otelhttp "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the storage service endpoint HTTP handlers.
type Server struct {
	Mounts                        []*MountPoint
	MonitorRequest                http.Handler
	Monitor                       http.Handler
	ListAips                      http.Handler
	CreateAip                     http.Handler
	SubmitAip                     http.Handler
	UpdateAip                     http.Handler
	DownloadAipRequest            http.Handler
	DownloadAip                   http.Handler
	MoveAip                       http.Handler
	MoveAipStatus                 http.Handler
	RejectAip                     http.Handler
	ShowAip                       http.Handler
	ListAipWorkflows              http.Handler
	RequestAipDeletion            http.Handler
	ReviewAipDeletion             http.Handler
	CancelAipDeletion             http.Handler
	DownloadDeletionReportRequest http.Handler
	DownloadDeletionReport        http.Handler
	ListLocations                 http.Handler
	CreateLocation                http.Handler
	ShowLocation                  http.Handler
	ListLocationAips              http.Handler
	CORS                          http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the storage service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *storage.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	upgrader goahttp.Upgrader,
	configurer *ConnConfigurer,
) *Server {
	if configurer == nil {
		configurer = &ConnConfigurer{}
	}
	return &Server{
		Mounts: []*MountPoint{
			{"MonitorRequest", "POST", "/storage/monitor"},
			{"Monitor", "GET", "/storage/monitor"},
			{"ListAips", "GET", "/storage/aips"},
			{"CreateAip", "POST", "/storage/aips"},
			{"SubmitAip", "POST", "/storage/aips/{uuid}/submit"},
			{"UpdateAip", "POST", "/storage/aips/{uuid}/update"},
			{"DownloadAipRequest", "POST", "/storage/aips/{uuid}/download"},
			{"DownloadAip", "GET", "/storage/aips/{uuid}/download"},
			{"MoveAip", "POST", "/storage/aips/{uuid}/store"},
			{"MoveAipStatus", "GET", "/storage/aips/{uuid}/store"},
			{"RejectAip", "POST", "/storage/aips/{uuid}/reject"},
			{"ShowAip", "GET", "/storage/aips/{uuid}"},
			{"ListAipWorkflows", "GET", "/storage/aips/{uuid}/workflows"},
			{"RequestAipDeletion", "POST", "/storage/aips/{uuid}/deletion-request"},
			{"ReviewAipDeletion", "POST", "/storage/aips/{uuid}/deletion-review"},
			{"CancelAipDeletion", "POST", "/storage/aips/{uuid}/deletion-cancel"},
			{"DownloadDeletionReportRequest", "POST", "/storage/deletion_report/{key}/download"},
			{"DownloadDeletionReport", "GET", "/storage/deletion_report/{key}/download"},
			{"ListLocations", "GET", "/storage/locations"},
			{"CreateLocation", "POST", "/storage/locations"},
			{"ShowLocation", "GET", "/storage/locations/{uuid}"},
			{"ListLocationAips", "GET", "/storage/locations/{uuid}/aips"},
			{"CORS", "OPTIONS", "/storage/monitor"},
			{"CORS", "OPTIONS", "/storage/aips"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/submit"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/update"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/download"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/store"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/reject"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/workflows"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/deletion-request"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/deletion-review"},
			{"CORS", "OPTIONS", "/storage/aips/{uuid}/deletion-cancel"},
			{"CORS", "OPTIONS", "/storage/deletion_report/{key}/download"},
			{"CORS", "OPTIONS", "/storage/locations"},
			{"CORS", "OPTIONS", "/storage/locations/{uuid}"},
			{"CORS", "OPTIONS", "/storage/locations/{uuid}/aips"},
		},
		MonitorRequest:                NewMonitorRequestHandler(e.MonitorRequest, mux, decoder, encoder, errhandler, formatter),
		Monitor:                       NewMonitorHandler(e.Monitor, mux, decoder, encoder, errhandler, formatter, upgrader, configurer.MonitorFn),
		ListAips:                      NewListAipsHandler(e.ListAips, mux, decoder, encoder, errhandler, formatter),
		CreateAip:                     NewCreateAipHandler(e.CreateAip, mux, decoder, encoder, errhandler, formatter),
		SubmitAip:                     NewSubmitAipHandler(e.SubmitAip, mux, decoder, encoder, errhandler, formatter),
		UpdateAip:                     NewUpdateAipHandler(e.UpdateAip, mux, decoder, encoder, errhandler, formatter),
		DownloadAipRequest:            NewDownloadAipRequestHandler(e.DownloadAipRequest, mux, decoder, encoder, errhandler, formatter),
		DownloadAip:                   NewDownloadAipHandler(e.DownloadAip, mux, decoder, encoder, errhandler, formatter),
		MoveAip:                       NewMoveAipHandler(e.MoveAip, mux, decoder, encoder, errhandler, formatter),
		MoveAipStatus:                 NewMoveAipStatusHandler(e.MoveAipStatus, mux, decoder, encoder, errhandler, formatter),
		RejectAip:                     NewRejectAipHandler(e.RejectAip, mux, decoder, encoder, errhandler, formatter),
		ShowAip:                       NewShowAipHandler(e.ShowAip, mux, decoder, encoder, errhandler, formatter),
		ListAipWorkflows:              NewListAipWorkflowsHandler(e.ListAipWorkflows, mux, decoder, encoder, errhandler, formatter),
		RequestAipDeletion:            NewRequestAipDeletionHandler(e.RequestAipDeletion, mux, decoder, encoder, errhandler, formatter),
		ReviewAipDeletion:             NewReviewAipDeletionHandler(e.ReviewAipDeletion, mux, decoder, encoder, errhandler, formatter),
		CancelAipDeletion:             NewCancelAipDeletionHandler(e.CancelAipDeletion, mux, decoder, encoder, errhandler, formatter),
		DownloadDeletionReportRequest: NewDownloadDeletionReportRequestHandler(e.DownloadDeletionReportRequest, mux, decoder, encoder, errhandler, formatter),
		DownloadDeletionReport:        NewDownloadDeletionReportHandler(e.DownloadDeletionReport, mux, decoder, encoder, errhandler, formatter),
		ListLocations:                 NewListLocationsHandler(e.ListLocations, mux, decoder, encoder, errhandler, formatter),
		CreateLocation:                NewCreateLocationHandler(e.CreateLocation, mux, decoder, encoder, errhandler, formatter),
		ShowLocation:                  NewShowLocationHandler(e.ShowLocation, mux, decoder, encoder, errhandler, formatter),
		ListLocationAips:              NewListLocationAipsHandler(e.ListLocationAips, mux, decoder, encoder, errhandler, formatter),
		CORS:                          NewCORSHandler(),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "storage" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.MonitorRequest = m(s.MonitorRequest)
	s.Monitor = m(s.Monitor)
	s.ListAips = m(s.ListAips)
	s.CreateAip = m(s.CreateAip)
	s.SubmitAip = m(s.SubmitAip)
	s.UpdateAip = m(s.UpdateAip)
	s.DownloadAipRequest = m(s.DownloadAipRequest)
	s.DownloadAip = m(s.DownloadAip)
	s.MoveAip = m(s.MoveAip)
	s.MoveAipStatus = m(s.MoveAipStatus)
	s.RejectAip = m(s.RejectAip)
	s.ShowAip = m(s.ShowAip)
	s.ListAipWorkflows = m(s.ListAipWorkflows)
	s.RequestAipDeletion = m(s.RequestAipDeletion)
	s.ReviewAipDeletion = m(s.ReviewAipDeletion)
	s.CancelAipDeletion = m(s.CancelAipDeletion)
	s.DownloadDeletionReportRequest = m(s.DownloadDeletionReportRequest)
	s.DownloadDeletionReport = m(s.DownloadDeletionReport)
	s.ListLocations = m(s.ListLocations)
	s.CreateLocation = m(s.CreateLocation)
	s.ShowLocation = m(s.ShowLocation)
	s.ListLocationAips = m(s.ListLocationAips)
	s.CORS = m(s.CORS)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return storage.MethodNames[:] }

// Mount configures the mux to serve the storage endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountMonitorRequestHandler(mux, h.MonitorRequest)
	MountMonitorHandler(mux, h.Monitor)
	MountListAipsHandler(mux, h.ListAips)
	MountCreateAipHandler(mux, h.CreateAip)
	MountSubmitAipHandler(mux, h.SubmitAip)
	MountUpdateAipHandler(mux, h.UpdateAip)
	MountDownloadAipRequestHandler(mux, h.DownloadAipRequest)
	MountDownloadAipHandler(mux, h.DownloadAip)
	MountMoveAipHandler(mux, h.MoveAip)
	MountMoveAipStatusHandler(mux, h.MoveAipStatus)
	MountRejectAipHandler(mux, h.RejectAip)
	MountShowAipHandler(mux, h.ShowAip)
	MountListAipWorkflowsHandler(mux, h.ListAipWorkflows)
	MountRequestAipDeletionHandler(mux, h.RequestAipDeletion)
	MountReviewAipDeletionHandler(mux, h.ReviewAipDeletion)
	MountCancelAipDeletionHandler(mux, h.CancelAipDeletion)
	MountDownloadDeletionReportRequestHandler(mux, h.DownloadDeletionReportRequest)
	MountDownloadDeletionReportHandler(mux, h.DownloadDeletionReport)
	MountListLocationsHandler(mux, h.ListLocations)
	MountCreateLocationHandler(mux, h.CreateLocation)
	MountShowLocationHandler(mux, h.ShowLocation)
	MountListLocationAipsHandler(mux, h.ListLocationAips)
	MountCORSHandler(mux, h.CORS)
}

// Mount configures the mux to serve the storage endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountMonitorRequestHandler configures the mux to serve the "storage" service
// "monitor_request" endpoint.
func MountMonitorRequestHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/monitor", otelhttp.WithRouteTag("/storage/monitor", f).ServeHTTP)
}

// NewMonitorRequestHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "monitor_request" endpoint.
func NewMonitorRequestHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeMonitorRequestRequest(mux, decoder)
		encodeResponse = EncodeMonitorRequestResponse(encoder)
		encodeError    = EncodeMonitorRequestError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "monitor_request")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountMonitorHandler configures the mux to serve the "storage" service
// "monitor" endpoint.
func MountMonitorHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/monitor", otelhttp.WithRouteTag("/storage/monitor", f).ServeHTTP)
}

// NewMonitorHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "monitor" endpoint.
func NewMonitorHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
	upgrader goahttp.Upgrader,
	configurer goahttp.ConnConfigureFunc,
) http.Handler {
	var (
		decodeRequest = DecodeMonitorRequest(mux, decoder)
		encodeError   = EncodeMonitorError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "monitor")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		v := &storage.MonitorEndpointInput{
			Stream: &MonitorServerStream{
				upgrader:   upgrader,
				configurer: configurer,
				cancel:     cancel,
				w:          w,
				r:          r,
			},
			Payload: payload,
		}
		_, err = endpoint(ctx, v)
		if err != nil {
			var stream *MonitorServerStream
			if wrapper, ok := v.Stream.(interface{ Unwrap() any }); ok {
				stream = wrapper.Unwrap().(*MonitorServerStream)
			} else {
				stream = v.Stream.(*MonitorServerStream)
			}
			if stream != nil && stream.conn != nil {
				// Response writer has been hijacked, do not encode the error
				if errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
	})
}

// MountListAipsHandler configures the mux to serve the "storage" service
// "list_aips" endpoint.
func MountListAipsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/aips", otelhttp.WithRouteTag("/storage/aips", f).ServeHTTP)
}

// NewListAipsHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "list_aips" endpoint.
func NewListAipsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListAipsRequest(mux, decoder)
		encodeResponse = EncodeListAipsResponse(encoder)
		encodeError    = EncodeListAipsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list_aips")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountCreateAipHandler configures the mux to serve the "storage" service
// "create_aip" endpoint.
func MountCreateAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips", otelhttp.WithRouteTag("/storage/aips", f).ServeHTTP)
}

// NewCreateAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "create_aip" endpoint.
func NewCreateAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateAipRequest(mux, decoder)
		encodeResponse = EncodeCreateAipResponse(encoder)
		encodeError    = EncodeCreateAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "create_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountSubmitAipHandler configures the mux to serve the "storage" service
// "submit_aip" endpoint.
func MountSubmitAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/submit", otelhttp.WithRouteTag("/storage/aips/{uuid}/submit", f).ServeHTTP)
}

// NewSubmitAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "submit_aip" endpoint.
func NewSubmitAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSubmitAipRequest(mux, decoder)
		encodeResponse = EncodeSubmitAipResponse(encoder)
		encodeError    = EncodeSubmitAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "submit_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountUpdateAipHandler configures the mux to serve the "storage" service
// "update_aip" endpoint.
func MountUpdateAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/update", otelhttp.WithRouteTag("/storage/aips/{uuid}/update", f).ServeHTTP)
}

// NewUpdateAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "update_aip" endpoint.
func NewUpdateAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateAipRequest(mux, decoder)
		encodeResponse = EncodeUpdateAipResponse(encoder)
		encodeError    = EncodeUpdateAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "update_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountDownloadAipRequestHandler configures the mux to serve the "storage"
// service "download_aip_request" endpoint.
func MountDownloadAipRequestHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/download", otelhttp.WithRouteTag("/storage/aips/{uuid}/download", f).ServeHTTP)
}

// NewDownloadAipRequestHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "download_aip_request" endpoint.
func NewDownloadAipRequestHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDownloadAipRequestRequest(mux, decoder)
		encodeResponse = EncodeDownloadAipRequestResponse(encoder)
		encodeError    = EncodeDownloadAipRequestError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "download_aip_request")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountDownloadAipHandler configures the mux to serve the "storage" service
// "download_aip" endpoint.
func MountDownloadAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/aips/{uuid}/download", otelhttp.WithRouteTag("/storage/aips/{uuid}/download", f).ServeHTTP)
}

// NewDownloadAipHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "download_aip" endpoint.
func NewDownloadAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDownloadAipRequest(mux, decoder)
		encodeResponse = EncodeDownloadAipResponse(encoder)
		encodeError    = EncodeDownloadAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "download_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		o := res.(*storage.DownloadAipResponseData)
		defer o.Body.Close()
		if wt, ok := o.Body.(io.WriterTo); ok {
			if err := encodeResponse(ctx, w, o.Result); err != nil {
				if errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			n, err := wt.WriteTo(w)
			if err != nil {
				if n == 0 {
					if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
						errhandler(ctx, w, err)
					}
				} else {
					http.NewResponseController(w).Flush()
					panic(http.ErrAbortHandler) // too late to write an error
				}
			}
			return
		}
		// handle immediate read error like a returned error
		buf := bufio.NewReader(o.Body)
		if _, err := buf.Peek(1); err != nil && err != io.EOF {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, o.Result); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if _, err := io.Copy(w, buf); err != nil {
			http.NewResponseController(w).Flush()
			panic(http.ErrAbortHandler) // too late to write an error
		}
	})
}

// MountMoveAipHandler configures the mux to serve the "storage" service
// "move_aip" endpoint.
func MountMoveAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/store", otelhttp.WithRouteTag("/storage/aips/{uuid}/store", f).ServeHTTP)
}

// NewMoveAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "move_aip" endpoint.
func NewMoveAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeMoveAipRequest(mux, decoder)
		encodeResponse = EncodeMoveAipResponse(encoder)
		encodeError    = EncodeMoveAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "move_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountMoveAipStatusHandler configures the mux to serve the "storage" service
// "move_aip_status" endpoint.
func MountMoveAipStatusHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/aips/{uuid}/store", otelhttp.WithRouteTag("/storage/aips/{uuid}/store", f).ServeHTTP)
}

// NewMoveAipStatusHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "move_aip_status" endpoint.
func NewMoveAipStatusHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeMoveAipStatusRequest(mux, decoder)
		encodeResponse = EncodeMoveAipStatusResponse(encoder)
		encodeError    = EncodeMoveAipStatusError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "move_aip_status")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountRejectAipHandler configures the mux to serve the "storage" service
// "reject_aip" endpoint.
func MountRejectAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/reject", otelhttp.WithRouteTag("/storage/aips/{uuid}/reject", f).ServeHTTP)
}

// NewRejectAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "reject_aip" endpoint.
func NewRejectAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRejectAipRequest(mux, decoder)
		encodeResponse = EncodeRejectAipResponse(encoder)
		encodeError    = EncodeRejectAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "reject_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountShowAipHandler configures the mux to serve the "storage" service
// "show_aip" endpoint.
func MountShowAipHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/aips/{uuid}", otelhttp.WithRouteTag("/storage/aips/{uuid}", f).ServeHTTP)
}

// NewShowAipHandler creates a HTTP handler which loads the HTTP request and
// calls the "storage" service "show_aip" endpoint.
func NewShowAipHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeShowAipRequest(mux, decoder)
		encodeResponse = EncodeShowAipResponse(encoder)
		encodeError    = EncodeShowAipError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "show_aip")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountListAipWorkflowsHandler configures the mux to serve the "storage"
// service "list_aip_workflows" endpoint.
func MountListAipWorkflowsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/aips/{uuid}/workflows", otelhttp.WithRouteTag("/storage/aips/{uuid}/workflows", f).ServeHTTP)
}

// NewListAipWorkflowsHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "list_aip_workflows" endpoint.
func NewListAipWorkflowsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListAipWorkflowsRequest(mux, decoder)
		encodeResponse = EncodeListAipWorkflowsResponse(encoder)
		encodeError    = EncodeListAipWorkflowsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list_aip_workflows")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountRequestAipDeletionHandler configures the mux to serve the "storage"
// service "request_aip_deletion" endpoint.
func MountRequestAipDeletionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/deletion-request", otelhttp.WithRouteTag("/storage/aips/{uuid}/deletion-request", f).ServeHTTP)
}

// NewRequestAipDeletionHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "request_aip_deletion" endpoint.
func NewRequestAipDeletionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRequestAipDeletionRequest(mux, decoder)
		encodeResponse = EncodeRequestAipDeletionResponse(encoder)
		encodeError    = EncodeRequestAipDeletionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "request_aip_deletion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountReviewAipDeletionHandler configures the mux to serve the "storage"
// service "review_aip_deletion" endpoint.
func MountReviewAipDeletionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/deletion-review", otelhttp.WithRouteTag("/storage/aips/{uuid}/deletion-review", f).ServeHTTP)
}

// NewReviewAipDeletionHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "review_aip_deletion" endpoint.
func NewReviewAipDeletionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeReviewAipDeletionRequest(mux, decoder)
		encodeResponse = EncodeReviewAipDeletionResponse(encoder)
		encodeError    = EncodeReviewAipDeletionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "review_aip_deletion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountCancelAipDeletionHandler configures the mux to serve the "storage"
// service "cancel_aip_deletion" endpoint.
func MountCancelAipDeletionHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/aips/{uuid}/deletion-cancel", otelhttp.WithRouteTag("/storage/aips/{uuid}/deletion-cancel", f).ServeHTTP)
}

// NewCancelAipDeletionHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "cancel_aip_deletion" endpoint.
func NewCancelAipDeletionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCancelAipDeletionRequest(mux, decoder)
		encodeResponse = EncodeCancelAipDeletionResponse(encoder)
		encodeError    = EncodeCancelAipDeletionError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "cancel_aip_deletion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountDownloadDeletionReportRequestHandler configures the mux to serve the
// "storage" service "download_deletion_report_request" endpoint.
func MountDownloadDeletionReportRequestHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/deletion_report/{key}/download", otelhttp.WithRouteTag("/storage/deletion_report/{key}/download", f).ServeHTTP)
}

// NewDownloadDeletionReportRequestHandler creates a HTTP handler which loads
// the HTTP request and calls the "storage" service
// "download_deletion_report_request" endpoint.
func NewDownloadDeletionReportRequestHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDownloadDeletionReportRequestRequest(mux, decoder)
		encodeResponse = EncodeDownloadDeletionReportRequestResponse(encoder)
		encodeError    = EncodeDownloadDeletionReportRequestError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "download_deletion_report_request")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountDownloadDeletionReportHandler configures the mux to serve the "storage"
// service "download_deletion_report" endpoint.
func MountDownloadDeletionReportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/deletion_report/{key}/download", otelhttp.WithRouteTag("/storage/deletion_report/{key}/download", f).ServeHTTP)
}

// NewDownloadDeletionReportHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "download_deletion_report" endpoint.
func NewDownloadDeletionReportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDownloadDeletionReportRequest(mux, decoder)
		encodeResponse = EncodeDownloadDeletionReportResponse(encoder)
		encodeError    = EncodeDownloadDeletionReportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "download_deletion_report")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		o := res.(*storage.DownloadDeletionReportResponseData)
		defer o.Body.Close()
		if wt, ok := o.Body.(io.WriterTo); ok {
			if err := encodeResponse(ctx, w, o.Result); err != nil {
				if errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			n, err := wt.WriteTo(w)
			if err != nil {
				if n == 0 {
					if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
						errhandler(ctx, w, err)
					}
				} else {
					http.NewResponseController(w).Flush()
					panic(http.ErrAbortHandler) // too late to write an error
				}
			}
			return
		}
		// handle immediate read error like a returned error
		buf := bufio.NewReader(o.Body)
		if _, err := buf.Peek(1); err != nil && err != io.EOF {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, o.Result); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if _, err := io.Copy(w, buf); err != nil {
			http.NewResponseController(w).Flush()
			panic(http.ErrAbortHandler) // too late to write an error
		}
	})
}

// MountListLocationsHandler configures the mux to serve the "storage" service
// "list_locations" endpoint.
func MountListLocationsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/locations", otelhttp.WithRouteTag("/storage/locations", f).ServeHTTP)
}

// NewListLocationsHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "list_locations" endpoint.
func NewListLocationsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListLocationsRequest(mux, decoder)
		encodeResponse = EncodeListLocationsResponse(encoder)
		encodeError    = EncodeListLocationsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list_locations")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountCreateLocationHandler configures the mux to serve the "storage" service
// "create_location" endpoint.
func MountCreateLocationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/storage/locations", otelhttp.WithRouteTag("/storage/locations", f).ServeHTTP)
}

// NewCreateLocationHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "create_location" endpoint.
func NewCreateLocationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateLocationRequest(mux, decoder)
		encodeResponse = EncodeCreateLocationResponse(encoder)
		encodeError    = EncodeCreateLocationError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "create_location")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountShowLocationHandler configures the mux to serve the "storage" service
// "show_location" endpoint.
func MountShowLocationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/locations/{uuid}", otelhttp.WithRouteTag("/storage/locations/{uuid}", f).ServeHTTP)
}

// NewShowLocationHandler creates a HTTP handler which loads the HTTP request
// and calls the "storage" service "show_location" endpoint.
func NewShowLocationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeShowLocationRequest(mux, decoder)
		encodeResponse = EncodeShowLocationResponse(encoder)
		encodeError    = EncodeShowLocationError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "show_location")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountListLocationAipsHandler configures the mux to serve the "storage"
// service "list_location_aips" endpoint.
func MountListLocationAipsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := HandleStorageOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/storage/locations/{uuid}/aips", otelhttp.WithRouteTag("/storage/locations/{uuid}/aips", f).ServeHTTP)
}

// NewListLocationAipsHandler creates a HTTP handler which loads the HTTP
// request and calls the "storage" service "list_location_aips" endpoint.
func NewListLocationAipsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListLocationAipsRequest(mux, decoder)
		encodeResponse = EncodeListLocationAipsResponse(encoder)
		encodeError    = EncodeListLocationAipsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list_location_aips")
		ctx = context.WithValue(ctx, goa.ServiceKey, "storage")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service storage.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = HandleStorageOrigin(h)
	mux.Handle("OPTIONS", "/storage/monitor", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/submit", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/update", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/download", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/store", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/reject", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/workflows", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/deletion-request", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/deletion-review", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/aips/{uuid}/deletion-cancel", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/deletion_report/{key}/download", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/locations", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/locations/{uuid}", h.ServeHTTP)
	mux.Handle("OPTIONS", "/storage/locations/{uuid}/aips", h.ServeHTTP)
}

// NewCORSHandler creates a HTTP handler which returns a simple 204 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(204)
	})
}

// HandleStorageOrigin applies the CORS response headers corresponding to the
// origin for the service storage.
func HandleStorageOrigin(h http.Handler) http.Handler {
	originStr0, present := os.LookupEnv("ENDURO_API_CORS_ORIGIN")
	if !present {
		panic("CORS origin environment variable \"ENDURO_API_CORS_ORIGIN\" not set!")
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			h.ServeHTTP(w, r)
			return
		}
		if cors.MatchOrigin(origin, originStr0) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, DELETE, OPTIONS")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
				w.WriteHeader(204)
				return
			}
			h.ServeHTTP(w, r)
			return
		}
		h.ServeHTTP(w, r)
		return
	})
}
