// Code generated by goa v3.22.2, DO NOT EDIT.
//
// ingest HTTP client CLI support package
//
// Command:
// $ goa gen github.com/artefactual-sdps/enduro/internal/api/design -o
// internal/api

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	ingest "github.com/artefactual-sdps/enduro/internal/api/gen/ingest"
	goa "goa.design/goa/v3/pkg"
)

// BuildMonitorRequestPayload builds the payload for the ingest monitor_request
// endpoint from CLI flags.
func BuildMonitorRequestPayload(ingestMonitorRequestToken string) (*ingest.MonitorRequestPayload, error) {
	var token *string
	{
		if ingestMonitorRequestToken != "" {
			token = &ingestMonitorRequestToken
		}
	}
	v := &ingest.MonitorRequestPayload{}
	v.Token = token

	return v, nil
}

// BuildMonitorPayload builds the payload for the ingest monitor endpoint from
// CLI flags.
func BuildMonitorPayload(ingestMonitorTicket string) (*ingest.MonitorPayload, error) {
	var ticket *string
	{
		if ingestMonitorTicket != "" {
			ticket = &ingestMonitorTicket
		}
	}
	v := &ingest.MonitorPayload{}
	v.Ticket = ticket

	return v, nil
}

// BuildListSipsPayload builds the payload for the ingest list_sips endpoint
// from CLI flags.
func BuildListSipsPayload(ingestListSipsName string, ingestListSipsAipUUID string, ingestListSipsEarliestCreatedTime string, ingestListSipsLatestCreatedTime string, ingestListSipsStatus string, ingestListSipsUploaderUUID string, ingestListSipsBatchUUID string, ingestListSipsLimit string, ingestListSipsOffset string, ingestListSipsToken string) (*ingest.ListSipsPayload, error) {
	var err error
	var name *string
	{
		if ingestListSipsName != "" {
			name = &ingestListSipsName
		}
	}
	var aipUUID *string
	{
		if ingestListSipsAipUUID != "" {
			aipUUID = &ingestListSipsAipUUID
			err = goa.MergeErrors(err, goa.ValidateFormat("aip_uuid", *aipUUID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var earliestCreatedTime *string
	{
		if ingestListSipsEarliestCreatedTime != "" {
			earliestCreatedTime = &ingestListSipsEarliestCreatedTime
			err = goa.MergeErrors(err, goa.ValidateFormat("earliest_created_time", *earliestCreatedTime, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var latestCreatedTime *string
	{
		if ingestListSipsLatestCreatedTime != "" {
			latestCreatedTime = &ingestListSipsLatestCreatedTime
			err = goa.MergeErrors(err, goa.ValidateFormat("latest_created_time", *latestCreatedTime, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if ingestListSipsStatus != "" {
			status = &ingestListSipsStatus
			if !(*status == "error" || *status == "failed" || *status == "queued" || *status == "processing" || *status == "pending" || *status == "ingested") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"error", "failed", "queued", "processing", "pending", "ingested"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var uploaderUUID *string
	{
		if ingestListSipsUploaderUUID != "" {
			uploaderUUID = &ingestListSipsUploaderUUID
			err = goa.MergeErrors(err, goa.ValidateFormat("uploader_uuid", *uploaderUUID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var batchUUID *string
	{
		if ingestListSipsBatchUUID != "" {
			batchUUID = &ingestListSipsBatchUUID
			err = goa.MergeErrors(err, goa.ValidateFormat("batch_uuid", *batchUUID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var limit *int
	{
		if ingestListSipsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListSipsLimit, 10, strconv.IntSize)
			val := int(v)
			limit = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
		}
	}
	var offset *int
	{
		if ingestListSipsOffset != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListSipsOffset, 10, strconv.IntSize)
			val := int(v)
			offset = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
		}
	}
	var token *string
	{
		if ingestListSipsToken != "" {
			token = &ingestListSipsToken
		}
	}
	v := &ingest.ListSipsPayload{}
	v.Name = name
	v.AipUUID = aipUUID
	v.EarliestCreatedTime = earliestCreatedTime
	v.LatestCreatedTime = latestCreatedTime
	v.Status = status
	v.UploaderUUID = uploaderUUID
	v.BatchUUID = batchUUID
	v.Limit = limit
	v.Offset = offset
	v.Token = token

	return v, nil
}

// BuildShowSipPayload builds the payload for the ingest show_sip endpoint from
// CLI flags.
func BuildShowSipPayload(ingestShowSipUUID string, ingestShowSipToken string) (*ingest.ShowSipPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestShowSipUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestShowSipToken != "" {
			token = &ingestShowSipToken
		}
	}
	v := &ingest.ShowSipPayload{}
	v.UUID = uuid
	v.Token = token

	return v, nil
}

// BuildListSipWorkflowsPayload builds the payload for the ingest
// list_sip_workflows endpoint from CLI flags.
func BuildListSipWorkflowsPayload(ingestListSipWorkflowsUUID string, ingestListSipWorkflowsToken string) (*ingest.ListSipWorkflowsPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestListSipWorkflowsUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestListSipWorkflowsToken != "" {
			token = &ingestListSipWorkflowsToken
		}
	}
	v := &ingest.ListSipWorkflowsPayload{}
	v.UUID = uuid
	v.Token = token

	return v, nil
}

// BuildConfirmSipPayload builds the payload for the ingest confirm_sip
// endpoint from CLI flags.
func BuildConfirmSipPayload(ingestConfirmSipBody string, ingestConfirmSipUUID string, ingestConfirmSipToken string) (*ingest.ConfirmSipPayload, error) {
	var err error
	var body ConfirmSipRequestBody
	{
		err = json.Unmarshal([]byte(ingestConfirmSipBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"location_uuid\": \"d1845cb6-a5ea-474a-9ab8-26f9bcd919f5\"\n   }'")
		}
	}
	var uuid string
	{
		uuid = ingestConfirmSipUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestConfirmSipToken != "" {
			token = &ingestConfirmSipToken
		}
	}
	v := &ingest.ConfirmSipPayload{
		LocationUUID: body.LocationUUID,
	}
	v.UUID = uuid
	v.Token = token

	return v, nil
}

// BuildRejectSipPayload builds the payload for the ingest reject_sip endpoint
// from CLI flags.
func BuildRejectSipPayload(ingestRejectSipUUID string, ingestRejectSipToken string) (*ingest.RejectSipPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestRejectSipUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestRejectSipToken != "" {
			token = &ingestRejectSipToken
		}
	}
	v := &ingest.RejectSipPayload{}
	v.UUID = uuid
	v.Token = token

	return v, nil
}

// BuildAddSipPayload builds the payload for the ingest add_sip endpoint from
// CLI flags.
func BuildAddSipPayload(ingestAddSipSourceID string, ingestAddSipKey string, ingestAddSipToken string) (*ingest.AddSipPayload, error) {
	var err error
	var sourceID string
	{
		sourceID = ingestAddSipSourceID
		err = goa.MergeErrors(err, goa.ValidateFormat("source_id", sourceID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var key string
	{
		key = ingestAddSipKey
	}
	var token *string
	{
		if ingestAddSipToken != "" {
			token = &ingestAddSipToken
		}
	}
	v := &ingest.AddSipPayload{}
	v.SourceID = sourceID
	v.Key = key
	v.Token = token

	return v, nil
}

// BuildUploadSipPayload builds the payload for the ingest upload_sip endpoint
// from CLI flags.
func BuildUploadSipPayload(ingestUploadSipContentType string, ingestUploadSipToken string) (*ingest.UploadSipPayload, error) {
	var err error
	var contentType string
	{
		if ingestUploadSipContentType != "" {
			contentType = ingestUploadSipContentType
			err = goa.MergeErrors(err, goa.ValidatePattern("content_type", contentType, "multipart/[^;]+; boundary=.+"))
			if err != nil {
				return nil, err
			}
		}
	}
	var token *string
	{
		if ingestUploadSipToken != "" {
			token = &ingestUploadSipToken
		}
	}
	v := &ingest.UploadSipPayload{}
	v.ContentType = contentType
	v.Token = token

	return v, nil
}

// BuildDownloadSipRequestPayload builds the payload for the ingest
// download_sip_request endpoint from CLI flags.
func BuildDownloadSipRequestPayload(ingestDownloadSipRequestUUID string, ingestDownloadSipRequestToken string) (*ingest.DownloadSipRequestPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestDownloadSipRequestUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestDownloadSipRequestToken != "" {
			token = &ingestDownloadSipRequestToken
		}
	}
	v := &ingest.DownloadSipRequestPayload{}
	v.UUID = uuid
	v.Token = token

	return v, nil
}

// BuildDownloadSipPayload builds the payload for the ingest download_sip
// endpoint from CLI flags.
func BuildDownloadSipPayload(ingestDownloadSipUUID string, ingestDownloadSipTicket string) (*ingest.DownloadSipPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestDownloadSipUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var ticket *string
	{
		if ingestDownloadSipTicket != "" {
			ticket = &ingestDownloadSipTicket
		}
	}
	v := &ingest.DownloadSipPayload{}
	v.UUID = uuid
	v.Ticket = ticket

	return v, nil
}

// BuildListUsersPayload builds the payload for the ingest list_users endpoint
// from CLI flags.
func BuildListUsersPayload(ingestListUsersEmail string, ingestListUsersName string, ingestListUsersLimit string, ingestListUsersOffset string, ingestListUsersToken string) (*ingest.ListUsersPayload, error) {
	var err error
	var email *string
	{
		if ingestListUsersEmail != "" {
			email = &ingestListUsersEmail
		}
	}
	var name *string
	{
		if ingestListUsersName != "" {
			name = &ingestListUsersName
		}
	}
	var limit *int
	{
		if ingestListUsersLimit != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListUsersLimit, 10, strconv.IntSize)
			val := int(v)
			limit = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
		}
	}
	var offset *int
	{
		if ingestListUsersOffset != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListUsersOffset, 10, strconv.IntSize)
			val := int(v)
			offset = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
		}
	}
	var token *string
	{
		if ingestListUsersToken != "" {
			token = &ingestListUsersToken
		}
	}
	v := &ingest.ListUsersPayload{}
	v.Email = email
	v.Name = name
	v.Limit = limit
	v.Offset = offset
	v.Token = token

	return v, nil
}

// BuildListSipSourceObjectsPayload builds the payload for the ingest
// list_sip_source_objects endpoint from CLI flags.
func BuildListSipSourceObjectsPayload(ingestListSipSourceObjectsUUID string, ingestListSipSourceObjectsLimit string, ingestListSipSourceObjectsCursor string, ingestListSipSourceObjectsToken string) (*ingest.ListSipSourceObjectsPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestListSipSourceObjectsUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var limit *int
	{
		if ingestListSipSourceObjectsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListSipSourceObjectsLimit, 10, strconv.IntSize)
			val := int(v)
			limit = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
		}
	}
	var cursor *string
	{
		if ingestListSipSourceObjectsCursor != "" {
			cursor = &ingestListSipSourceObjectsCursor
		}
	}
	var token *string
	{
		if ingestListSipSourceObjectsToken != "" {
			token = &ingestListSipSourceObjectsToken
		}
	}
	v := &ingest.ListSipSourceObjectsPayload{}
	v.UUID = uuid
	v.Limit = limit
	v.Cursor = cursor
	v.Token = token

	return v, nil
}

// BuildAddBatchPayload builds the payload for the ingest add_batch endpoint
// from CLI flags.
func BuildAddBatchPayload(ingestAddBatchBody string, ingestAddBatchToken string) (*ingest.AddBatchPayload, error) {
	var err error
	var body AddBatchRequestBody
	{
		err = json.Unmarshal([]byte(ingestAddBatchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"identifier\": \"abc123\",\n      \"keys\": [\n         \"abc123\"\n      ],\n      \"source_id\": \"d1845cb6-a5ea-474a-9ab8-26f9bcd919f5\"\n   }'")
		}
		if body.Keys == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("keys", "body"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.source_id", body.SourceID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestAddBatchToken != "" {
			token = &ingestAddBatchToken
		}
	}
	v := &ingest.AddBatchPayload{
		SourceID:   body.SourceID,
		Identifier: body.Identifier,
	}
	if body.Keys != nil {
		v.Keys = make([]string, len(body.Keys))
		for i, val := range body.Keys {
			v.Keys[i] = val
		}
	} else {
		v.Keys = []string{}
	}
	v.Token = token

	return v, nil
}

// BuildListBatchesPayload builds the payload for the ingest list_batches
// endpoint from CLI flags.
func BuildListBatchesPayload(ingestListBatchesIdentifier string, ingestListBatchesEarliestCreatedTime string, ingestListBatchesLatestCreatedTime string, ingestListBatchesStatus string, ingestListBatchesUploaderUUID string, ingestListBatchesLimit string, ingestListBatchesOffset string, ingestListBatchesToken string) (*ingest.ListBatchesPayload, error) {
	var err error
	var identifier *string
	{
		if ingestListBatchesIdentifier != "" {
			identifier = &ingestListBatchesIdentifier
		}
	}
	var earliestCreatedTime *string
	{
		if ingestListBatchesEarliestCreatedTime != "" {
			earliestCreatedTime = &ingestListBatchesEarliestCreatedTime
			err = goa.MergeErrors(err, goa.ValidateFormat("earliest_created_time", *earliestCreatedTime, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var latestCreatedTime *string
	{
		if ingestListBatchesLatestCreatedTime != "" {
			latestCreatedTime = &ingestListBatchesLatestCreatedTime
			err = goa.MergeErrors(err, goa.ValidateFormat("latest_created_time", *latestCreatedTime, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if ingestListBatchesStatus != "" {
			status = &ingestListBatchesStatus
			if !(*status == "queued" || *status == "processing" || *status == "pending" || *status == "ingested" || *status == "canceled") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"queued", "processing", "pending", "ingested", "canceled"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var uploaderUUID *string
	{
		if ingestListBatchesUploaderUUID != "" {
			uploaderUUID = &ingestListBatchesUploaderUUID
			err = goa.MergeErrors(err, goa.ValidateFormat("uploader_uuid", *uploaderUUID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var limit *int
	{
		if ingestListBatchesLimit != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListBatchesLimit, 10, strconv.IntSize)
			val := int(v)
			limit = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
		}
	}
	var offset *int
	{
		if ingestListBatchesOffset != "" {
			var v int64
			v, err = strconv.ParseInt(ingestListBatchesOffset, 10, strconv.IntSize)
			val := int(v)
			offset = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
		}
	}
	var token *string
	{
		if ingestListBatchesToken != "" {
			token = &ingestListBatchesToken
		}
	}
	v := &ingest.ListBatchesPayload{}
	v.Identifier = identifier
	v.EarliestCreatedTime = earliestCreatedTime
	v.LatestCreatedTime = latestCreatedTime
	v.Status = status
	v.UploaderUUID = uploaderUUID
	v.Limit = limit
	v.Offset = offset
	v.Token = token

	return v, nil
}

// BuildShowBatchPayload builds the payload for the ingest show_batch endpoint
// from CLI flags.
func BuildShowBatchPayload(ingestShowBatchUUID string, ingestShowBatchToken string) (*ingest.ShowBatchPayload, error) {
	var err error
	var uuid string
	{
		uuid = ingestShowBatchUUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uuid", uuid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if ingestShowBatchToken != "" {
			token = &ingestShowBatchToken
		}
	}
	v := &ingest.ShowBatchPayload{}
	v.UUID = uuid
	v.Token = token

	return v, nil
}
