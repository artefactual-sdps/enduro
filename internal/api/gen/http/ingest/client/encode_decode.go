// Code generated by goa v3.15.2, DO NOT EDIT.
//
// ingest HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/artefactual-sdps/enduro/internal/api/design -o
// internal/api

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"

	ingest "github.com/artefactual-sdps/enduro/internal/api/gen/ingest"
	ingestviews "github.com/artefactual-sdps/enduro/internal/api/gen/ingest/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildMonitorRequestRequest instantiates a HTTP request object with method
// and path set to call the "ingest" service "monitor_request" endpoint
func (c *Client) BuildMonitorRequestRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: MonitorRequestIngestPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "monitor_request", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeMonitorRequestRequest returns an encoder for requests sent to the
// ingest monitor_request server.
func EncodeMonitorRequestRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.MonitorRequestPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "monitor_request", "*ingest.MonitorRequestPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeMonitorRequestResponse returns a decoder for responses returned by the
// ingest monitor_request endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeMonitorRequestResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusInternalServerError
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeMonitorRequestResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				ticket    *string
				ticketRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "enduro-ws-ticket":
					ticketRaw = c.Value
				}
			}
			if ticketRaw != "" {
				ticket = &ticketRaw
			}
			res := NewMonitorRequestResultOK(ticket)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body MonitorRequestNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor_request", err)
			}
			err = ValidateMonitorRequestNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "monitor_request", err)
			}
			return nil, NewMonitorRequestNotAvailable(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor_request", err)
			}
			return nil, NewMonitorRequestForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor_request", err)
			}
			return nil, NewMonitorRequestUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "monitor_request", resp.StatusCode, string(body))
		}
	}
}

// BuildMonitorRequest instantiates a HTTP request object with method and path
// set to call the "ingest" service "monitor" endpoint
func (c *Client) BuildMonitorRequest(ctx context.Context, v any) (*http.Request, error) {
	scheme := c.scheme
	switch c.scheme {
	case "http":
		scheme = "ws"
	case "https":
		scheme = "wss"
	}
	u := &url.URL{Scheme: scheme, Host: c.host, Path: MonitorIngestPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "monitor", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeMonitorRequest returns an encoder for requests sent to the ingest
// monitor server.
func EncodeMonitorRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.MonitorPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "monitor", "*ingest.MonitorPayload", v)
		}
		if p.Ticket != nil {
			v := *p.Ticket
			req.AddCookie(&http.Cookie{
				Name:  "enduro-ws-ticket",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeMonitorResponse returns a decoder for responses returned by the ingest
// monitor endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeMonitorResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusInternalServerError
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeMonitorResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body MonitorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor", err)
			}
			err = ValidateMonitorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "monitor", err)
			}
			res := NewMonitorEventOK(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body MonitorNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor", err)
			}
			err = ValidateMonitorNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "monitor", err)
			}
			return nil, NewMonitorNotAvailable(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor", err)
			}
			return nil, NewMonitorForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "monitor", err)
			}
			return nil, NewMonitorUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "monitor", resp.StatusCode, string(body))
		}
	}
}

// BuildListSipsRequest instantiates a HTTP request object with method and path
// set to call the "ingest" service "list_sips" endpoint
func (c *Client) BuildListSipsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSipsIngestPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "list_sips", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListSipsRequest returns an encoder for requests sent to the ingest
// list_sips server.
func EncodeListSipsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.ListSipsPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "list_sips", "*ingest.ListSipsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		if p.AipID != nil {
			values.Add("aip_id", *p.AipID)
		}
		if p.EarliestCreatedTime != nil {
			values.Add("earliest_created_time", *p.EarliestCreatedTime)
		}
		if p.LatestCreatedTime != nil {
			values.Add("latest_created_time", *p.LatestCreatedTime)
		}
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		if p.Limit != nil {
			values.Add("limit", fmt.Sprintf("%v", *p.Limit))
		}
		if p.Offset != nil {
			values.Add("offset", fmt.Sprintf("%v", *p.Offset))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListSipsResponse returns a decoder for responses returned by the
// ingest list_sips endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeListSipsResponse may return the following errors:
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListSipsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSipsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sips", err)
			}
			p := NewListSipsSIPsOK(&body)
			view := "default"
			vres := &ingestviews.SIPs{Projected: p, View: view}
			if err = ingestviews.ValidateSIPs(vres); err != nil {
				return nil, goahttp.ErrValidationError("ingest", "list_sips", err)
			}
			res := ingest.NewSIPs(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListSipsNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sips", err)
			}
			err = ValidateListSipsNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "list_sips", err)
			}
			return nil, NewListSipsNotValid(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sips", err)
			}
			return nil, NewListSipsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sips", err)
			}
			return nil, NewListSipsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "list_sips", resp.StatusCode, string(body))
		}
	}
}

// BuildShowSipRequest instantiates a HTTP request object with method and path
// set to call the "ingest" service "show_sip" endpoint
func (c *Client) BuildShowSipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id uint
	)
	{
		p, ok := v.(*ingest.ShowSipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("ingest", "show_sip", "*ingest.ShowSipPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ShowSipIngestPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "show_sip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeShowSipRequest returns an encoder for requests sent to the ingest
// show_sip server.
func EncodeShowSipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.ShowSipPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "show_sip", "*ingest.ShowSipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeShowSipResponse returns a decoder for responses returned by the ingest
// show_sip endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeShowSipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_found" (type *ingest.SIPNotFound): http.StatusNotFound
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeShowSipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ShowSipResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "show_sip", err)
			}
			p := NewShowSipSIPOK(&body)
			view := "default"
			vres := &ingestviews.SIP{Projected: p, View: view}
			if err = ingestviews.ValidateSIP(vres); err != nil {
				return nil, goahttp.ErrValidationError("ingest", "show_sip", err)
			}
			res := ingest.NewSIP(vres)
			return res, nil
		case http.StatusConflict:
			var (
				body ShowSipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "show_sip", err)
			}
			err = ValidateShowSipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "show_sip", err)
			}
			return nil, NewShowSipNotAvailable(&body)
		case http.StatusNotFound:
			var (
				body ShowSipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "show_sip", err)
			}
			err = ValidateShowSipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "show_sip", err)
			}
			return nil, NewShowSipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "show_sip", err)
			}
			return nil, NewShowSipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "show_sip", err)
			}
			return nil, NewShowSipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "show_sip", resp.StatusCode, string(body))
		}
	}
}

// BuildListSipWorkflowsRequest instantiates a HTTP request object with method
// and path set to call the "ingest" service "list_sip_workflows" endpoint
func (c *Client) BuildListSipWorkflowsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id uint
	)
	{
		p, ok := v.(*ingest.ListSipWorkflowsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("ingest", "list_sip_workflows", "*ingest.ListSipWorkflowsPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSipWorkflowsIngestPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "list_sip_workflows", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListSipWorkflowsRequest returns an encoder for requests sent to the
// ingest list_sip_workflows server.
func EncodeListSipWorkflowsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.ListSipWorkflowsPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "list_sip_workflows", "*ingest.ListSipWorkflowsPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListSipWorkflowsResponse returns a decoder for responses returned by
// the ingest list_sip_workflows endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListSipWorkflowsResponse may return the following errors:
//   - "not_found" (type *ingest.SIPNotFound): http.StatusNotFound
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListSipWorkflowsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSipWorkflowsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sip_workflows", err)
			}
			p := NewListSipWorkflowsSIPWorkflowsOK(&body)
			view := "default"
			vres := &ingestviews.SIPWorkflows{Projected: p, View: view}
			if err = ingestviews.ValidateSIPWorkflows(vres); err != nil {
				return nil, goahttp.ErrValidationError("ingest", "list_sip_workflows", err)
			}
			res := ingest.NewSIPWorkflows(vres)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListSipWorkflowsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sip_workflows", err)
			}
			err = ValidateListSipWorkflowsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "list_sip_workflows", err)
			}
			return nil, NewListSipWorkflowsNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sip_workflows", err)
			}
			return nil, NewListSipWorkflowsForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "list_sip_workflows", err)
			}
			return nil, NewListSipWorkflowsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "list_sip_workflows", resp.StatusCode, string(body))
		}
	}
}

// BuildConfirmSipRequest instantiates a HTTP request object with method and
// path set to call the "ingest" service "confirm_sip" endpoint
func (c *Client) BuildConfirmSipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id uint
	)
	{
		p, ok := v.(*ingest.ConfirmSipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("ingest", "confirm_sip", "*ingest.ConfirmSipPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ConfirmSipIngestPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "confirm_sip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeConfirmSipRequest returns an encoder for requests sent to the ingest
// confirm_sip server.
func EncodeConfirmSipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.ConfirmSipPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "confirm_sip", "*ingest.ConfirmSipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewConfirmSipRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("ingest", "confirm_sip", err)
		}
		return nil
	}
}

// DecodeConfirmSipResponse returns a decoder for responses returned by the
// ingest confirm_sip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeConfirmSipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *ingest.SIPNotFound): http.StatusNotFound
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeConfirmSipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusConflict:
			var (
				body ConfirmSipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "confirm_sip", err)
			}
			err = ValidateConfirmSipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "confirm_sip", err)
			}
			return nil, NewConfirmSipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body ConfirmSipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "confirm_sip", err)
			}
			err = ValidateConfirmSipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "confirm_sip", err)
			}
			return nil, NewConfirmSipNotValid(&body)
		case http.StatusNotFound:
			var (
				body ConfirmSipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "confirm_sip", err)
			}
			err = ValidateConfirmSipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "confirm_sip", err)
			}
			return nil, NewConfirmSipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "confirm_sip", err)
			}
			return nil, NewConfirmSipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "confirm_sip", err)
			}
			return nil, NewConfirmSipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "confirm_sip", resp.StatusCode, string(body))
		}
	}
}

// BuildRejectSipRequest instantiates a HTTP request object with method and
// path set to call the "ingest" service "reject_sip" endpoint
func (c *Client) BuildRejectSipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id uint
	)
	{
		p, ok := v.(*ingest.RejectSipPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("ingest", "reject_sip", "*ingest.RejectSipPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RejectSipIngestPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "reject_sip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRejectSipRequest returns an encoder for requests sent to the ingest
// reject_sip server.
func EncodeRejectSipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*ingest.RejectSipPayload)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "reject_sip", "*ingest.RejectSipPayload", v)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeRejectSipResponse returns a decoder for responses returned by the
// ingest reject_sip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeRejectSipResponse may return the following errors:
//   - "not_available" (type *goa.ServiceError): http.StatusConflict
//   - "not_valid" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *ingest.SIPNotFound): http.StatusNotFound
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeRejectSipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusConflict:
			var (
				body RejectSipNotAvailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "reject_sip", err)
			}
			err = ValidateRejectSipNotAvailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "reject_sip", err)
			}
			return nil, NewRejectSipNotAvailable(&body)
		case http.StatusBadRequest:
			var (
				body RejectSipNotValidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "reject_sip", err)
			}
			err = ValidateRejectSipNotValidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "reject_sip", err)
			}
			return nil, NewRejectSipNotValid(&body)
		case http.StatusNotFound:
			var (
				body RejectSipNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "reject_sip", err)
			}
			err = ValidateRejectSipNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "reject_sip", err)
			}
			return nil, NewRejectSipNotFound(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "reject_sip", err)
			}
			return nil, NewRejectSipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "reject_sip", err)
			}
			return nil, NewRejectSipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "reject_sip", resp.StatusCode, string(body))
		}
	}
}

// BuildUploadSipRequest instantiates a HTTP request object with method and
// path set to call the "ingest" service "upload_sip" endpoint
func (c *Client) BuildUploadSipRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		body io.Reader
	)
	rd, ok := v.(*ingest.UploadSipRequestData)
	if !ok {
		return nil, goahttp.ErrInvalidType("ingest", "upload_sip", "ingest.UploadSipRequestData", v)
	}
	body = rd.Body
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UploadSipIngestPath()}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("ingest", "upload_sip", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUploadSipRequest returns an encoder for requests sent to the ingest
// upload_sip server.
func EncodeUploadSipRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		data, ok := v.(*ingest.UploadSipRequestData)
		if !ok {
			return goahttp.ErrInvalidType("ingest", "upload_sip", "*ingest.UploadSipRequestData", v)
		}
		p := data.Payload
		{
			head := p.ContentType
			req.Header.Set("Content-Type", head)
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeUploadSipResponse returns a decoder for responses returned by the
// ingest upload_sip endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUploadSipResponse may return the following errors:
//   - "invalid_media_type" (type *goa.ServiceError): http.StatusBadRequest
//   - "invalid_multipart_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "internal_error" (type *goa.ServiceError): http.StatusInternalServerError
//   - "forbidden" (type ingest.Forbidden): http.StatusForbidden
//   - "unauthorized" (type ingest.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeUploadSipResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			return nil, nil
		case http.StatusBadRequest:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invalid_media_type":
				var (
					body UploadSipInvalidMediaTypeResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("ingest", "upload_sip", err)
				}
				err = ValidateUploadSipInvalidMediaTypeResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("ingest", "upload_sip", err)
				}
				return nil, NewUploadSipInvalidMediaType(&body)
			case "invalid_multipart_request":
				var (
					body UploadSipInvalidMultipartRequestResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("ingest", "upload_sip", err)
				}
				err = ValidateUploadSipInvalidMultipartRequestResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("ingest", "upload_sip", err)
				}
				return nil, NewUploadSipInvalidMultipartRequest(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("ingest", "upload_sip", resp.StatusCode, string(body))
			}
		case http.StatusInternalServerError:
			var (
				body UploadSipInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "upload_sip", err)
			}
			err = ValidateUploadSipInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("ingest", "upload_sip", err)
			}
			return nil, NewUploadSipInternalError(&body)
		case http.StatusForbidden:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "upload_sip", err)
			}
			return nil, NewUploadSipForbidden(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("ingest", "upload_sip", err)
			}
			return nil, NewUploadSipUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("ingest", "upload_sip", resp.StatusCode, string(body))
		}
	}
}

// // BuildUploadSipStreamPayload creates a streaming endpoint request payload
// from the method payload and the path to the file to be streamed
func BuildUploadSipStreamPayload(payload any, fpath string) (*ingest.UploadSipRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &ingest.UploadSipRequestData{
		Payload: payload.(*ingest.UploadSipPayload),
		Body:    f,
	}, nil
}

// unmarshalSIPResponseBodyToIngestviewsSIPView builds a value of type
// *ingestviews.SIPView from a value of type *SIPResponseBody.
func unmarshalSIPResponseBodyToIngestviewsSIPView(v *SIPResponseBody) *ingestviews.SIPView {
	res := &ingestviews.SIPView{
		ID:          v.ID,
		Name:        v.Name,
		Status:      v.Status,
		AipID:       v.AipID,
		CreatedAt:   v.CreatedAt,
		StartedAt:   v.StartedAt,
		CompletedAt: v.CompletedAt,
	}

	return res
}

// unmarshalEnduroPageResponseBodyToIngestviewsEnduroPageView builds a value of
// type *ingestviews.EnduroPageView from a value of type
// *EnduroPageResponseBody.
func unmarshalEnduroPageResponseBodyToIngestviewsEnduroPageView(v *EnduroPageResponseBody) *ingestviews.EnduroPageView {
	res := &ingestviews.EnduroPageView{
		Limit:  v.Limit,
		Offset: v.Offset,
		Total:  v.Total,
	}

	return res
}

// unmarshalSIPWorkflowResponseBodyToIngestviewsSIPWorkflowView builds a value
// of type *ingestviews.SIPWorkflowView from a value of type
// *SIPWorkflowResponseBody.
func unmarshalSIPWorkflowResponseBodyToIngestviewsSIPWorkflowView(v *SIPWorkflowResponseBody) *ingestviews.SIPWorkflowView {
	if v == nil {
		return nil
	}
	res := &ingestviews.SIPWorkflowView{
		ID:          v.ID,
		TemporalID:  v.TemporalID,
		Type:        v.Type,
		Status:      v.Status,
		StartedAt:   v.StartedAt,
		CompletedAt: v.CompletedAt,
		SipID:       v.SipID,
	}
	if v.Tasks != nil {
		res.Tasks = make([]*ingestviews.SIPTaskView, len(v.Tasks))
		for i, val := range v.Tasks {
			res.Tasks[i] = unmarshalSIPTaskResponseBodyToIngestviewsSIPTaskView(val)
		}
	}

	return res
}

// unmarshalSIPTaskResponseBodyToIngestviewsSIPTaskView builds a value of type
// *ingestviews.SIPTaskView from a value of type *SIPTaskResponseBody.
func unmarshalSIPTaskResponseBodyToIngestviewsSIPTaskView(v *SIPTaskResponseBody) *ingestviews.SIPTaskView {
	if v == nil {
		return nil
	}
	res := &ingestviews.SIPTaskView{
		ID:          v.ID,
		TaskID:      v.TaskID,
		Name:        v.Name,
		Status:      v.Status,
		StartedAt:   v.StartedAt,
		CompletedAt: v.CompletedAt,
		Note:        v.Note,
		WorkflowID:  v.WorkflowID,
	}

	return res
}
