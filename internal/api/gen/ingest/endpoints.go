// Code generated by goa v3.22.2, DO NOT EDIT.
//
// ingest endpoints
//
// Command:
// $ goa gen github.com/artefactual-sdps/enduro/internal/api/design -o
// internal/api

package ingest

import (
	"context"
	"io"

	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// Endpoints wraps the "ingest" service endpoints.
type Endpoints struct {
	MonitorRequest       goa.Endpoint
	Monitor              goa.Endpoint
	ListSips             goa.Endpoint
	ShowSip              goa.Endpoint
	ListSipWorkflows     goa.Endpoint
	ConfirmSip           goa.Endpoint
	RejectSip            goa.Endpoint
	AddSip               goa.Endpoint
	UploadSip            goa.Endpoint
	DownloadSipRequest   goa.Endpoint
	DownloadSip          goa.Endpoint
	ListUsers            goa.Endpoint
	ListSipSourceObjects goa.Endpoint
	AddBatch             goa.Endpoint
	ListBatches          goa.Endpoint
	ShowBatch            goa.Endpoint
}

// MonitorEndpointInput holds both the payload and the server stream of the
// "monitor" method.
type MonitorEndpointInput struct {
	// Payload is the method payload.
	Payload *MonitorPayload
	// Stream is the server stream used by the "monitor" method to send data.
	Stream MonitorServerStream
}

// UploadSipRequestData holds both the payload and the HTTP request body reader
// of the "upload_sip" method.
type UploadSipRequestData struct {
	// Payload is the method payload.
	Payload *UploadSipPayload
	// Body streams the HTTP request body.
	Body io.ReadCloser
}

// DownloadSipResponseData holds both the result and the HTTP response body
// reader of the "download_sip" method.
type DownloadSipResponseData struct {
	// Result is the method result.
	Result *DownloadSipResult
	// Body streams the HTTP response body.
	Body io.ReadCloser
}

// NewEndpoints wraps the methods of the "ingest" service with endpoints.
func NewEndpoints(s Service) *Endpoints {
	// Casting service to Auther interface
	a := s.(Auther)
	return &Endpoints{
		MonitorRequest:       NewMonitorRequestEndpoint(s, a.JWTAuth),
		Monitor:              NewMonitorEndpoint(s),
		ListSips:             NewListSipsEndpoint(s, a.JWTAuth),
		ShowSip:              NewShowSipEndpoint(s, a.JWTAuth),
		ListSipWorkflows:     NewListSipWorkflowsEndpoint(s, a.JWTAuth),
		ConfirmSip:           NewConfirmSipEndpoint(s, a.JWTAuth),
		RejectSip:            NewRejectSipEndpoint(s, a.JWTAuth),
		AddSip:               NewAddSipEndpoint(s, a.JWTAuth),
		UploadSip:            NewUploadSipEndpoint(s, a.JWTAuth),
		DownloadSipRequest:   NewDownloadSipRequestEndpoint(s, a.JWTAuth),
		DownloadSip:          NewDownloadSipEndpoint(s),
		ListUsers:            NewListUsersEndpoint(s, a.JWTAuth),
		ListSipSourceObjects: NewListSipSourceObjectsEndpoint(s, a.JWTAuth),
		AddBatch:             NewAddBatchEndpoint(s, a.JWTAuth),
		ListBatches:          NewListBatchesEndpoint(s, a.JWTAuth),
		ShowBatch:            NewShowBatchEndpoint(s, a.JWTAuth),
	}
}

// Use applies the given middleware to all the "ingest" service endpoints.
func (e *Endpoints) Use(m func(goa.Endpoint) goa.Endpoint) {
	e.MonitorRequest = m(e.MonitorRequest)
	e.Monitor = m(e.Monitor)
	e.ListSips = m(e.ListSips)
	e.ShowSip = m(e.ShowSip)
	e.ListSipWorkflows = m(e.ListSipWorkflows)
	e.ConfirmSip = m(e.ConfirmSip)
	e.RejectSip = m(e.RejectSip)
	e.AddSip = m(e.AddSip)
	e.UploadSip = m(e.UploadSip)
	e.DownloadSipRequest = m(e.DownloadSipRequest)
	e.DownloadSip = m(e.DownloadSip)
	e.ListUsers = m(e.ListUsers)
	e.ListSipSourceObjects = m(e.ListSipSourceObjects)
	e.AddBatch = m(e.AddBatch)
	e.ListBatches = m(e.ListBatches)
	e.ShowBatch = m(e.ShowBatch)
}

// NewMonitorRequestEndpoint returns an endpoint function that calls the method
// "monitor_request" of service "ingest".
func NewMonitorRequestEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*MonitorRequestPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return s.MonitorRequest(ctx, p)
	}
}

// NewMonitorEndpoint returns an endpoint function that calls the method
// "monitor" of service "ingest".
func NewMonitorEndpoint(s Service) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		ep := req.(*MonitorEndpointInput)
		return nil, s.Monitor(ctx, ep.Payload, ep.Stream)
	}
}

// NewListSipsEndpoint returns an endpoint function that calls the method
// "list_sips" of service "ingest".
func NewListSipsEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ListSipsPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:list"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ListSips(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSIPs(res, "default")
		return vres, nil
	}
}

// NewShowSipEndpoint returns an endpoint function that calls the method
// "show_sip" of service "ingest".
func NewShowSipEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ShowSipPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:read"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ShowSip(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSIP(res, "default")
		return vres, nil
	}
}

// NewListSipWorkflowsEndpoint returns an endpoint function that calls the
// method "list_sip_workflows" of service "ingest".
func NewListSipWorkflowsEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ListSipWorkflowsPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:workflows:list"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ListSipWorkflows(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSIPWorkflows(res, "default")
		return vres, nil
	}
}

// NewConfirmSipEndpoint returns an endpoint function that calls the method
// "confirm_sip" of service "ingest".
func NewConfirmSipEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ConfirmSipPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:review"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return nil, s.ConfirmSip(ctx, p)
	}
}

// NewRejectSipEndpoint returns an endpoint function that calls the method
// "reject_sip" of service "ingest".
func NewRejectSipEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*RejectSipPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:review"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return nil, s.RejectSip(ctx, p)
	}
}

// NewAddSipEndpoint returns an endpoint function that calls the method
// "add_sip" of service "ingest".
func NewAddSipEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*AddSipPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:create"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return s.AddSip(ctx, p)
	}
}

// NewUploadSipEndpoint returns an endpoint function that calls the method
// "upload_sip" of service "ingest".
func NewUploadSipEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		ep := req.(*UploadSipRequestData)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:upload"},
		}
		var token string
		if ep.Payload.Token != nil {
			token = *ep.Payload.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return s.UploadSip(ctx, ep.Payload, ep.Body)
	}
}

// NewDownloadSipRequestEndpoint returns an endpoint function that calls the
// method "download_sip_request" of service "ingest".
func NewDownloadSipRequestEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*DownloadSipRequestPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sips:download"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return s.DownloadSipRequest(ctx, p)
	}
}

// NewDownloadSipEndpoint returns an endpoint function that calls the method
// "download_sip" of service "ingest".
func NewDownloadSipEndpoint(s Service) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*DownloadSipPayload)
		res, body, err := s.DownloadSip(ctx, p)
		if err != nil {
			return nil, err
		}
		return &DownloadSipResponseData{Result: res, Body: body}, nil
	}
}

// NewListUsersEndpoint returns an endpoint function that calls the method
// "list_users" of service "ingest".
func NewListUsersEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ListUsersPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:users:list"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ListUsers(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedUsers(res, "default")
		return vres, nil
	}
}

// NewListSipSourceObjectsEndpoint returns an endpoint function that calls the
// method "list_sip_source_objects" of service "ingest".
func NewListSipSourceObjectsEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ListSipSourceObjectsPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:sipsources:objects:list"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ListSipSourceObjects(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSIPSourceObjects(res, "default")
		return vres, nil
	}
}

// NewAddBatchEndpoint returns an endpoint function that calls the method
// "add_batch" of service "ingest".
func NewAddBatchEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*AddBatchPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:batches:create"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		return s.AddBatch(ctx, p)
	}
}

// NewListBatchesEndpoint returns an endpoint function that calls the method
// "list_batches" of service "ingest".
func NewListBatchesEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ListBatchesPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:batches:list"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ListBatches(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedBatches(res, "default")
		return vres, nil
	}
}

// NewShowBatchEndpoint returns an endpoint function that calls the method
// "show_batch" of service "ingest".
func NewShowBatchEndpoint(s Service, authJWTFn security.AuthJWTFunc) goa.Endpoint {
	return func(ctx context.Context, req any) (any, error) {
		p := req.(*ShowBatchPayload)
		var err error
		sc := security.JWTScheme{
			Name:           "jwt",
			Scopes:         []string{"ingest:batches:create", "ingest:batches:list", "ingest:batches:read", "ingest:sips:create", "ingest:sips:download", "ingest:sips:list", "ingest:sips:read", "ingest:sips:review", "ingest:sips:upload", "ingest:sips:workflows:list", "ingest:sipsources:objects:list", "ingest:users:list", "storage:aips:create", "storage:aips:deletion:request", "storage:aips:deletion:review", "storage:aips:download", "storage:aips:list", "storage:aips:move", "storage:aips:read", "storage:aips:review", "storage:aips:submit", "storage:aips:workflows:list", "storage:deletion_report:download", "storage:locations:aips:list", "storage:locations:create", "storage:locations:list", "storage:locations:read"},
			RequiredScopes: []string{"ingest:batches:read"},
		}
		var token string
		if p.Token != nil {
			token = *p.Token
		}
		ctx, err = authJWTFn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ShowBatch(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedBatch(res, "default")
		return vres, nil
	}
}
